# B1修复方案：网络优化

## 1. 弱网络环境适配

### 1.1 网络状态监控与自适应策略

```javascript
// utils/network-monitor.js
const NetworkMonitor = {
  // 网络类型枚举
  NetworkType: {
    UNKNOWN: 'unknown',
    WIFI: 'wifi',
    _2G: '2g',
    _3G: '3g',
    _4G: '4g',
    _5G: '5g',
    NONE: 'none'
  },
  
  // 网络状态
  _state: {
    type: 'unknown',     // 网络类型
    connected: true,     // 是否连接
    isWeakNetwork: false, // 是否弱网络
    lastCheckTime: 0     // 上次检查时间
  },
  
  // 状态变化回调函数
  _callbacks: [],
  
  // 初始化网络监控
  init() {
    // 获取初始网络状态
    this.checkNetworkStatus();
    
    // 监听网络状态变化
    wx.onNetworkStatusChange(res => {
      this._state.connected = res.isConnected;
      this._state.type = res.networkType;
      this._state.isWeakNetwork = this._checkIfWeakNetwork(res.networkType);
      this._state.lastCheckTime = Date.now();
      
      // 触发回调
      this._notifyCallbacks();
    });
    
    // 定期检查网络状态 (每30秒)
    setInterval(() => {
      this.checkNetworkStatus();
    }, 30000);
    
    return this;
  },
  
  // 检查当前网络状态
  checkNetworkStatus() {
    return new Promise((resolve) => {
      wx.getNetworkType({
        success: (res) => {
          this._state.type = res.networkType;
          this._state.connected = res.networkType !== 'none';
          this._state.isWeakNetwork = this._checkIfWeakNetwork(res.networkType);
          this._state.lastCheckTime = Date.now();
          
          // 触发回调
          this._notifyCallbacks();
          
          resolve(this._state);
        },
        fail: () => {
          // 如果获取失败，假设网络不佳
          this._state.isWeakNetwork = true;
          this._state.lastCheckTime = Date.now();
          this._notifyCallbacks();
          resolve(this._state);
        }
      });
    });
  },
  
  // 判断是否弱网络
  _checkIfWeakNetwork(networkType) {
    // 无网络或2G网络视为弱网络
    return networkType === 'none' || networkType === '2g';
  },
  
  // 注册状态变化回调
  onNetworkChange(callback) {
    if (typeof callback === 'function') {
      this._callbacks.push(callback);
      
      // 立即以当前状态触发一次回调
      callback(this._state);
    }
    return this;
  },
  
  // 移除回调
  offNetworkChange(callback) {
    const index = this._callbacks.indexOf(callback);
    if (index > -1) {
      this._callbacks.splice(index, 1);
    }
    return this;
  },
  
  // 触发所有回调
  _notifyCallbacks() {
    this._callbacks.forEach(callback => {
      try {
        callback(this._state);
      } catch (e) {
        console.error('Error in network change callback:', e);
      }
    });
  },
  
  // 获取当前网络状态
  getNetworkState() {
    // 如果上次检查时间超过60秒，重新检查
    if (Date.now() - this._state.lastCheckTime > 60000) {
      this.checkNetworkStatus();
    }
    return { ...this._state };
  },
  
  // 判断当前是否适合上传大文件
  isSuitableForLargeUpload() {
    const state = this.getNetworkState();
    // 仅WiFi、4G、5G网络适合上传大文件
    return state.connected && 
           (state.type === this.NetworkType.WIFI || 
            state.type === this.NetworkType._4G || 
            state.type === this.NetworkType._5G);
  }
};

module.exports = NetworkMonitor;
```

### 1.2 弱网络自适应图片加载

```javascript
// services/adaptive-image-loader.js
const NetworkMonitor = require('../utils/network-monitor');

const AdaptiveImageLoader = {
  // 缓存的图片质量级别设置
  _qualitySettings: {
    wifi: {
      defaultQuality: 'high',
      preloadQuality: 'medium'
    },
    _4g: {
      defaultQuality: 'medium',
      preloadQuality: 'low'
    },
    _3g: {
      defaultQuality: 'low',
      preloadQuality: 'low'
    },
    _2g: {
      defaultQuality: 'minimum',
      preloadQuality: 'none'
    },
    slow: {
      defaultQuality: 'minimum',
      preloadQuality: 'none'
    }
  },
  
  // 质量级别对应的图片尺寸和压缩参数
  _qualityParams: {
    high: { width: 0, height: 0, quality: 100 },    // 原图
    medium: { width: 1200, height: 1200, quality: 85 }, // 中等压缩
    low: { width: 720, height: 720, quality: 75 },   // 低质量
    minimum: { width: 360, height: 360, quality: 60 } // 最低质量
  },
  
  // 当前环境的网络质量设置
  _currentQualitySetting: null,
  
  // 初始化
  init() {
    // 监听网络变化，自动调整加载策略
    NetworkMonitor.onNetworkChange(this._adjustQualitySettings.bind(this));
    
    // 立即进行一次设置
    this._adjustQualitySettings(NetworkMonitor.getNetworkState());
    
    return this;
  },
  
  // 根据网络状态调整图片质量设置
  _adjustQualitySettings(networkState) {
    if (!networkState) return;
    
    // 根据网络类型选择对应的质量设置
    if (networkState.type === 'wifi') {
      this._currentQualitySetting = this._qualitySettings.wifi;
    } else if (networkState.type === '4g' || networkState.type === '5g') {
      this._currentQualitySetting = this._qualitySettings._4g;
    } else if (networkState.type === '3g') {
      this._currentQualitySetting = this._qualitySettings._3g;
    } else if (networkState.type === '2g') {
      this._currentQualitySetting = this._qualitySettings._2g;
    } else if (networkState.type === 'none' || networkState.isWeakNetwork) {
      this._currentQualitySetting = this._qualitySettings.slow;
    } else {
      // 默认使用3G的设置作为保守策略
      this._currentQualitySetting = this._qualitySettings._3g;
    }
  },
  
  // 获取指定质量级别的参数
  getQualityParams(qualityLevel) {
    return this._qualityParams[qualityLevel] || this._qualityParams.medium;
  },
  
  // 获取当前网络环境下的默认加载质量
  getCurrentDefaultQuality() {
    return this._currentQualitySetting?.defaultQuality || 'medium';
  },
  
  // 获取当前网络环境下的预加载质量
  getCurrentPreloadQuality() {
    return this._currentQualitySetting?.preloadQuality || 'low';
  },
  
  // 自适应加载图片 
  loadImage(imageUrl, options = {}) {
    // 合并选项与默认值
    const opts = {
      forceQuality: null,       // 强制指定质量
      fallbackToCache: true,    // 失败时回退到缓存
      timeout: 15000,          // 超时时间(ms)
      retryCount: 2,           // 重试次数
      retryDelay: 1000,        // 重试延迟(ms)
      ...options
    };
    
    // 获取质量级别参数
    const qualityLevel = opts.forceQuality || this.getCurrentDefaultQuality();
    const qualityParams = this.getQualityParams(qualityLevel);
    
    // 构建加载URL (添加压缩参数)
    let loadUrl = imageUrl;
    if (qualityParams.width > 0 || qualityParams.height > 0 || qualityParams.quality < 100) {
      // 假设服务器支持通过URL参数调整图片大小和质量
      // 实际实现需要根据后端服务的API进行调整
      const separator = loadUrl.includes('?') ? '&' : '?';
      loadUrl += `${separator}`;
      
      if (qualityParams.width > 0) {
        loadUrl += `width=${qualityParams.width}&`;
      }
      
      if (qualityParams.height > 0) {
        loadUrl += `height=${qualityParams.height}&`;
      }
      
      if (qualityParams.quality < 100) {
        loadUrl += `quality=${qualityParams.quality}`;
      }
      
      // 移除最后一个可能的&
      if (loadUrl.endsWith('&')) {
        loadUrl = loadUrl.substring(0, loadUrl.length - 1);
      }
    }
    
    return new Promise((resolve, reject) => {
      let retryAttempt = 0;
      let timeoutTimer = null;
      
      const attemptLoad = () => {
        // 设置超时定时器
        if (timeoutTimer) clearTimeout(timeoutTimer);
        timeoutTimer = setTimeout(() => {
          console.warn(`Image load timeout: ${loadUrl}`);
          
          if (retryAttempt < opts.retryCount) {
            retryAttempt++;
            setTimeout(attemptLoad, opts.retryDelay);
          } else if (opts.fallbackToCache) {
            // 尝试从缓存加载更低质量版本
            this._loadFromCache(imageUrl)
              .then(resolve)
              .catch(reject);
          } else {
            reject(new Error('Image load timeout after retries'));
          }
        }, opts.timeout);
        
        // 开始加载图片
        wx.getImageInfo({
          src: loadUrl,
          success: (res) => {
            if (timeoutTimer) clearTimeout(timeoutTimer);
            resolve(res);
          },
          fail: (err) => {
            console.warn(`Image load failed (${retryAttempt+1}/${opts.retryCount+1}): ${loadUrl}`, err);
            
            if (retryAttempt < opts.retryCount) {
              retryAttempt++;
              setTimeout(attemptLoad, opts.retryDelay);
            } else if (opts.fallbackToCache) {
              // 尝试从缓存加载更低质量版本
              this._loadFromCache(imageUrl)
                .then(resolve)
                .catch(reject);
            } else {
              if (timeoutTimer) clearTimeout(timeoutTimer);
              reject(err);
            }
          }
        });
      };
      
      attemptLoad();
    });
  },
  
  // 从缓存加载低质量版本
  _loadFromCache(imageUrl) {
    // 这里应该实现从本地缓存加载已有的较低质量版本
    // 实际实现依赖于应用的缓存策略
    return new Promise((resolve, reject) => {
      // 示例实现：尝试加载最低质量的图片
      const qualityParams = this.getQualityParams('minimum');
      const separator = imageUrl.includes('?') ? '&' : '?';
      const cacheUrl = `${imageUrl}${separator}width=${qualityParams.width}&height=${qualityParams.height}&quality=${qualityParams.quality}&use_cache=1`;
      
      wx.getImageInfo({
        src: cacheUrl,
        success: resolve,
        fail: reject
      });
    });
  }
};

module.exports = AdaptiveImageLoader;
```

## 2. 断点续传与失败重试

### 2.1 断点续传管理器

```javascript
// services/resumable-uploader.js
const NetworkMonitor = require('../utils/network-monitor');
const SecurityFilter = require('../utils/security-filter');

class ResumableUploader {
  constructor(options = {}) {
    // 默认配置
    this.config = {
      chunkSize: 512 * 1024,          // 分片大小，默认512KB
      maxRetries: 3,                  // 最大重试次数
      retryDelay: 1000,               // 重试延迟(ms)
      timeout: 30000,                 // 超时时间(ms)
      concurrentUploads: 1,           // 同时上传的分片数，弱网环境下建议为1
      ...options
    };
    
    // 上传任务队列
    this.uploadQueue = [];
    
    // 当前活跃上传任务
    this.activeUploads = 0;
    
    // 初始化网络监听
    this._setupNetworkListener();
  }
  
  // 设置网络状态监听
  _setupNetworkListener() {
    NetworkMonitor.onNetworkChange((state) => {
      // 网络状态变化时调整上传策略
      if (state.isWeakNetwork) {
        // 弱网环境下，减少并发上传数
        this.config.concurrentUploads = 1;
        this.config.chunkSize = 256 * 1024; // 减小分片大小为256KB
      } else if (state.type === 'wifi') {
        // WiFi环境下，提高并发
        this.config.concurrentUploads = 3;
        this.config.chunkSize = 1024 * 1024; // 增大分片大小为1MB
      } else {
        // 其他网络环境
        this.config.concurrentUploads = 2;
        this.config.chunkSize = 512 * 1024; // 使用默认分片大小
      }
    });
  }
  
  // 添加上传任务
  addUploadTask(file, uploadOptions = {}) {
    return new Promise((resolve, reject) => {
      // 获取文件信息
      wx.getFileInfo({
        filePath: file.path,
        success: (res) => {
          // 生成安全的文件名
          const safeFileName = SecurityFilter.sanitizeFileName(file.name || `photo_${Date.now()}`);
          
          // 创建上传任务
          const task = {
            id: `upload_${Date.now()}_${Math.floor(Math.random() * 1000)}`,
            file: {
              path: file.path,
              size: res.size,
              name: safeFileName
            },
            options: {
              url: uploadOptions.url || '',
              header: uploadOptions.header || {},
              formData: uploadOptions.formData || {},
              success: uploadOptions.success || null,
              fail: uploadOptions.fail || null,
              complete: uploadOptions.complete || null
            },
            state: {
              status: 'pending',       // 任务状态：pending, uploading, paused, complete, failed
              uploadedSize: 0,         // 已上传大小
              progress: 0,             // 上传进度(0-100)
              chunkIndex: 0,           // 当前分片索引
              totalChunks: Math.ceil(res.size / this.config.chunkSize), // 总分片数
              retries: 0,              // 当前重试次数
              error: null,             // 错误信息
              chunks: []               // 分片信息
            },
            controlCallbacks: {
              resolve,                 // Promise resolve回调
              reject                   // Promise reject回调
            }
          };
          
          // 初始化分片信息
          this._initChunks(task);
          
          // 添加到上传队列
          this.uploadQueue.push(task);
          
          // 尝试开始上传
          this._processQueue();
        },
        fail: (err) => {
          reject(err);
        }
      });
    });
  }
  
  // 初始化文件分片
  _initChunks(task) {
    const { file, state } = task;
    const { chunkSize } = this.config;
    
    state.chunks = [];
    
    for (let i = 0; i < state.totalChunks; i++) {
      const start = i * chunkSize;
      const end = Math.min(start + chunkSize, file.size);
      
      state.chunks.push({
        index: i,
        start,
        end,
        size: end - start,
        status: 'pending',  // pending, uploading, complete, failed
        retries: 0
      });
    }
  }
  
  // 处理上传队列
  _processQueue() {
    // 检查是否有空闲上传槽
    while (this.activeUploads < this.config.concurrentUploads && this.uploadQueue.length > 0) {
      // 查找下一个待上传的任务
      const nextTaskIndex = this.uploadQueue.findIndex(task => 
        task.state.status === 'pending' || task.state.status === 'uploading'
      );
      
      if (nextTaskIndex === -1) break;
      
      const task = this.uploadQueue[nextTaskIndex];
      this._uploadTask(task);
    }
  }
  
  // 上传指定任务
  _uploadTask(task) {
    if (task.state.status === 'complete' || task.state.status === 'failed') {
      return;
    }
    
    task.state.status = 'uploading';
    this.activeUploads++;
    
    // 查找下一个待上传的分片
    const nextChunkIndex = task.state.chunks.findIndex(chunk => 
      chunk.status === 'pending' || chunk.status === 'failed'
    );
    
    if (nextChunkIndex === -1) {
      // 所有分片都已上传完成
      this._completeTask(task);
      return;
    }
    
    const chunk = task.state.chunks[nextChunkIndex];
    chunk.status = 'uploading';
    
    // 创建文件分片
    const filePath = task.file.path;
    
    // 读取文件分片
    wx.getFileSystemManager().readFile({
      filePath,
      position: chunk.start,
      length: chunk.size,
      success: (res) => {
        this._uploadChunk(task, chunk, res.data);
      },
      fail: (err) => {
        console.error('Failed to read file chunk:', err);
        chunk.status = 'failed';
        this._retryChunkOrFail(task, chunk, err);
      }
    });
  }
  
  // 上传分片
  _uploadChunk(task, chunk, chunkData) {
    const { id, file, options } = task;
    
    // 构建上传请求参数
    const uploadTask = wx.uploadFile({
      url: options.url,
      filePath: file.path,
      name: 'file',
      header: {
        ...options.header,
        'Content-Type': 'multipart/form-data',
        'Content-Range': `bytes ${chunk.start}-${chunk.end-1}/${file.size}`
      },
      formData: {
        ...options.formData,
        taskId: id,
        fileName: file.name,
        chunkIndex: chunk.index,
        totalChunks: task.state.totalChunks
      },
      success: (res) => {
        try {
          const response = JSON.parse(res.data);
          
          if (res.statusCode >= 200 && res.statusCode < 300) {
            // 上传成功
            chunk.status = 'complete';
            task.state.uploadedSize += chunk.size;
            task.state.progress = Math.floor((task.state.uploadedSize / file.size) * 100);
            
            // 继续上传下一个分片
            this.activeUploads--;
            this._uploadTask(task);
          } else {
            // 服务器返回错误
            chunk.status = 'failed';
            this._retryChunkOrFail(task, chunk, new Error(`Server error: ${res.statusCode}`));
          }
        } catch (err) {
          // 响应解析错误
          chunk.status = 'failed';
          this._retryChunkOrFail(task, chunk, err);
        }
      },
      fail: (err) => {
        // 上传失败
        chunk.status = 'failed';
        this._retryChunkOrFail(task, chunk, err);
      }
    });
    
    // 设置超时
    setTimeout(() => {
      if (chunk.status === 'uploading') {
        uploadTask.abort();
        chunk.status = 'failed';
        this._retryChunkOrFail(task, chunk, new Error('Upload timeout'));
      }
    }, this.config.timeout);
  }
  
  // 重试分片上传或标记任务失败
  _retryChunkOrFail(task, chunk, error) {
    this.activeUploads--;
    
    if (chunk.retries < this.config.maxRetries) {
      // 重试该分片
      chunk.retries++;
      chunk.status = 'pending';
      
      // 延迟重试
      setTimeout(() => {
        this._uploadTask(task);
      }, this.config.retryDelay);
    } else {
      // 超过最大重试次数，标记任务失败
      task.state.status = 'failed';
      task.state.error = error;
      
      if (task.options.fail) {
        task.options.fail(error);
      }
      
      if (task.controlCallbacks.reject) {
        task.controlCallbacks.reject(error);
      }
      
      // 处理下一个任务
      this._processQueue();
    }
  }
  
  // 完成任务
  _completeTask(task) {
    this.activeUploads--;
    task.state.status = 'complete';
    task.state.progress = 100;
    
    if (task.options.success) {
      task.options.success({
        taskId: task.id,
        fileName: task.file.name,
        size: task.file.size
      });
    }
    
    if (task.controlCallbacks.resolve) {
      task.controlCallbacks.resolve({
        taskId: task.id,
        fileName: task.file.name,
        size: task.file.size
      });
    }
    
    // 从队列中移除任务
    const index = this.uploadQueue.findIndex(t => t.id === task.id);
    if (index !== -1) {
      this.uploadQueue.splice(index, 1);
    }
    
    // 处理下一个任务
    this._processQueue();
  }
  
  // 暂停指定任务
  pauseTask(taskId) {
    const task = this.uploadQueue.find(t => t.id === taskId);
    if (task && task.state.status === 'uploading') {
      task.state.status = 'paused';
      this.activeUploads--;
      this._processQueue();
      return true;
    }
    return false;
  }
  
  // 恢复指定任务
  resumeTask(taskId) {
    const task = this.uploadQueue.find(t => t.id === taskId);
    if (task && task.state.status === 'paused') {
      task.state.status = 'pending';
      this._processQueue();
      return true;
    }
    return false;
  }
  
  // 取消指定任务
  cancelTask(taskId) {
    const index = this.uploadQueue.findIndex(t => t.id === taskId);
    if (index !== -1) {
      const task = this.uploadQueue[index];
      
      if (task.state.status === 'uploading') {
        this.activeUploads--;
      }
      
      // 从队列中移除任务
      this.uploadQueue.splice(index, 1);
      
      if (task.options.fail) {
        task.options.fail(new Error('Upload cancelled'));
      }
      
      if (task.controlCallbacks.reject) {
        task.controlCallbacks.reject(new Error('Upload cancelled'));
      }
      
      this._processQueue();
      return true;
    }
    return false;
  }
}

module.exports = ResumableUploader;
``` 