# B1修复方案：主动内存释放策略

## 1. 增强版图片缓存管理器

```javascript
// utils/enhanced-image-cache-manager.js
const EnhancedImageCacheManager = {
  // 继承原有属性
  ...ImageCacheManager,
  
  // 内存警告监听
  setupMemoryWarningListener() {
    wx.onMemoryWarning(res => {
      console.warn(`[内存警告] 级别: ${res.level}`);
      
      // 根据内存警告级别采取不同清理策略
      switch(res.level) {
        case 1: // 轻微
          this.cleanup();
          break;
        case 2: // 中度
          this.aggressiveCleanup();
          break;
        case 3: // 严重
          this.emergencyCleanup();
          break;
      }
    });
  },
  
  // 中度内存清理 - 清理所有原图和大部分预览图
  aggressiveCleanup() {
    // 清理所有原图缓存，只保留当前查看的图片
    const currentViewingKey = this._getCurrentViewingKey();
    
    // 删除除当前查看外的所有原图
    const origKeys = this.originalCache.keys();
    for (const key of origKeys) {
      if (key !== currentViewingKey) {
        this.removeImage(key, false);
      }
    }
    
    // 清理大部分预览图，只保留最近查看的少量图片
    while (this.thumbnailCache.size() > 3) {
      const oldestKey = this.thumbnailCache.keys()[0];
      this.removeImage(oldestKey, true);
    }
    
    console.info(`[内存管理] 积极清理完成，当前使用: ${(this.estimatedMemoryUsage / 1024 / 1024).toFixed(2)}MB`);
  },
  
  // 紧急内存清理 - 仅保留最小必要的缓存
  emergencyCleanup() {
    // 清理几乎所有缓存，包括当前查看图片的原图
    this.originalCache.clear();
    
    // 仅保留当前查看图片的缩略图
    const currentKey = this._getCurrentViewingKey();
    const thumbKeys = this.thumbnailCache.keys();
    for (const key of thumbKeys) {
      if (key !== `thumb_${currentKey}`) {
        this.removeImage(key, true);
      }
    }
    
    this.estimatedMemoryUsage = 0;
    console.warn('[内存管理] 紧急清理完成，已清理几乎所有缓存');
  },
  
  // 获取当前正在查看的图片Key
  _getCurrentViewingKey() {
    // 从全局状态或当前页面获取
    const app = getApp();
    if (app.globalData && app.globalData.currentViewingPhotoId) {
      return app.globalData.currentViewingPhotoId;
    }
    return '';
  }
};

module.exports = EnhancedImageCacheManager;
```

## 2. 照片预览组件优化

```javascript
// components/photo-viewer/photo-viewer.js
Component({
  properties: {
    photoList: {
      type: Array,
      value: []
    },
    currentIndex: {
      type: Number,
      value: 0
    }
  },
  
  data: {
    isZooming: false,
    showControls: true
  },
  
  lifetimes: {
    attached() {
      // 初始化时以低分辨率加载
      this._initWithThumbnails();
      
      // 设置内存警告监听
      this._setupMemoryListeners();
    },
    
    detached() {
      // 组件销毁时主动清理资源
      this._cleanupResources();
      
      // 取消事件监听
      if (this._memoryWarningHandler) {
        wx.offMemoryWarning(this._memoryWarningHandler);
      }
    }
  },
  
  methods: {
    // 初始化加载缩略图
    _initWithThumbnails() {
      const { photoList, currentIndex } = this.data;
      if (!photoList || photoList.length === 0) return;
      
      // 先加载当前图片的中等分辨率版本
      ImageLoadingStrategy.loadOptimalImage(
        photoList[currentIndex].id, 
        'preview'
      );
      
      // 预加载相邻图片的缩略图
      this._preloadAdjacentImages(currentIndex);
      
      // 更新全局状态
      this._updateGlobalViewingState(photoList[currentIndex].id);
    },
    
    // 设置内存监听
    _setupMemoryListeners() {
      this._memoryWarningHandler = res => {
        console.warn(`[照片预览] 收到内存警告，级别: ${res.level}`);
        
        // 降低当前显示图片质量
        if (res.level >= 2) {
          this.setData({ isZooming: false });
          this._downgradeCurrentImage();
        }
      };
      
      // 注册内存警告监听
      wx.onMemoryWarning(this._memoryWarningHandler);
    },
    
    // 降级当前图片显示质量
    _downgradeCurrentImage() {
      const { photoList, currentIndex } = this.data;
      if (!photoList || photoList.length === 0) return;
      
      // 强制使用中等分辨率或缩略图
      const currentPhoto = photoList[currentIndex];
      if (currentPhoto && currentPhoto.id) {
        // 尝试使用中等分辨率
        ImageLoadingStrategy.loadMediumImage(currentPhoto.id)
          .catch(() => {
            // 降级到缩略图
            return ImageLoadingStrategy.loadThumbnail(currentPhoto.id);
          });
      }
    },
    
    // 优化的图片切换逻辑
    onSwiperChange(e) {
      const current = e.detail.current;
      
      // 更新索引
      this.setData({ currentIndex: current, isZooming: false });
      
      // 延迟加载以保证滑动流畅
      setTimeout(() => {
        // 加载当前图片的中等分辨率版本
        const currentPhoto = this.data.photoList[current];
        if (currentPhoto && currentPhoto.id) {
          ImageLoadingStrategy.loadOptimalImage(
            currentPhoto.id, 
            'preview'
          );
          
          // 更新全局状态
          this._updateGlobalViewingState(currentPhoto.id);
        }
        
        // 预加载前后图片
        this._preloadAdjacentImages(current);
      }, 100);
      
      // 切换图片时主动清理不再需要的缓存
      this._cleanupUnusedImages(current);
    },
    
    // 预加载相邻图片
    _preloadAdjacentImages(currentIndex) {
      // 使用工具函数预加载
      preloadAdjacentImages(
        currentIndex, 
        this.data.photoList,
        'preview'
      );
    },
    
    // 更新全局正在查看的图片状态
    _updateGlobalViewingState(photoId) {
      const app = getApp();
      if (app.globalData) {
        app.globalData.currentViewingPhotoId = photoId;
      }
    },
    
    // 放大查看时的处理
    onImageTap() {
      if (this.data.isZooming) {
        // 已经在放大状态，切换回普通预览
        this.setData({ isZooming: false });
        return;
      }
      
      const current = this.data.currentIndex;
      const photo = this.data.photoList[current];
      
      // 先检查内存状态，决定是否允许加载原图
      wx.getStorageInfo({
        success: info => {
          const availableMemory = info.limitSize - info.currentSize;
          
          if (availableMemory > 10 * 1024 * 1024) { // 10MB阈值
            // 内存充足时加载原图并设置放大状态
            ImageLoadingStrategy.loadOptimalImage(photo.id, 'zoom');
            this.setData({ isZooming: true });
          } else {
            // 内存不足时提示用户
            wx.showToast({
              title: '内存不足，使用较低清晰度',
              icon: 'none'
            });
            // 但仍切换到放大状态，使用中等分辨率
            this.setData({ isZooming: true });
          }
        }
      });
    },
    
    // 清理不再需要的图片资源
    _cleanupUnusedImages(currentIndex) {
      const photoList = this.data.photoList;
      if (!photoList || photoList.length === 0) return;
      
      // 计算要保留的图片范围
      const keepStartIndex = Math.max(0, currentIndex - 1);
      const keepEndIndex = Math.min(photoList.length - 1, currentIndex + 1);
      
      // 清理范围外的高分辨率图片
      for (let i = 0; i < photoList.length; i++) {
        if (i < keepStartIndex || i > keepEndIndex) {
          const photo = photoList[i];
          if (photo && photo.id) {
            EnhancedImageCacheManager.removeImage(photo.id, false); // 清理原图
          }
        }
      }
    },
    
    // 组件销毁时清理资源
    _cleanupResources() {
      const photoList = this.data.photoList;
      if (!photoList || photoList.length === 0) return;
      
      // 清理所有原图缓存，仅保留缩略图
      for (let i = 0; i < photoList.length; i++) {
        const photo = photoList[i];
        if (photo && photo.id) {
          EnhancedImageCacheManager.removeImage(photo.id, false); // 清理原图
        }
      }
      
      // 更新全局状态
      this._updateGlobalViewingState('');
    }
  }
});
``` 