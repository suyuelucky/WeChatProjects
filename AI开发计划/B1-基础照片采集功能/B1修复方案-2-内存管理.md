# B1修复方案：内存管理优化

## 1. 图片加载策略重构

### 1.1 分级加载模式实现

```javascript
// utils/image-loading-strategy.js
const ImageLoadingStrategy = {
  // 加载模式：低分辨率(缩略图) -> 中等分辨率(预览图) -> 高分辨率(原图)
  THUMBNAIL: 'thumbnail',  // 200px宽度缩略图
  MEDIUM: 'medium',        // 800px宽度预览图
  ORIGINAL: 'original',    // 原始分辨率

  // 当前显示的图片级别
  currentLoadingMode: 'thumbnail',
  
  // 根据当前场景加载合适分辨率的图片
  loadOptimalImage(photoId, viewMode) {
    // 列表视图使用缩略图
    if (viewMode === 'list') {
      return this.loadThumbnail(photoId);
    }
    
    // 预览视图使用中等分辨率
    if (viewMode === 'preview') {
      return this.loadMediumImage(photoId);
    }
    
    // 放大查看时才加载原图，且仅加载当前查看的一张
    if (viewMode === 'zoom') {
      return this.loadOriginalImage(photoId);
    }
  },
  
  // 加载缩略图
  loadThumbnail(photoId, isPreload = false) {
    return this._loadImage(photoId, 'thumbnail', isPreload);
  },
  
  // 加载中等分辨率图片
  loadMediumImage(photoId, isPreload = false) {
    return this._loadImage(photoId, 'medium', isPreload);
  },
  
  // 加载原始分辨率图片
  loadOriginalImage(photoId, isPreload = false) {
    return this._loadImage(photoId, 'original', isPreload);
  },
  
  // 内部加载逻辑
  _loadImage(photoId, quality, isPreload) {
    return ImageService.getImageByQuality(photoId, quality);
  }
};

module.exports = ImageLoadingStrategy;
```

### 1.2 智能预加载策略

```javascript
// 图片预加载策略 - 只预加载当前图片相邻的图片
function preloadAdjacentImages(currentIndex, photoList, viewMode) {
  // 计算需要预加载的索引范围
  const start = Math.max(0, currentIndex - 2);
  const end = Math.min(photoList.length - 1, currentIndex + 2);
  
  // 对于预览模式，预加载中等分辨率
  if (viewMode === 'preview') {
    for (let i = start; i <= end; i++) {
      if (i !== currentIndex) {
        ImageLoadingStrategy.loadMediumImage(photoList[i].id, true); // true表示这是预加载
      }
    }
  }
  
  // 列表模式下预加载更多缩略图
  if (viewMode === 'list') {
    const preloadRange = 5; // 预加载前后5张
    for (let i = Math.max(0, currentIndex - preloadRange); 
         i <= Math.min(photoList.length - 1, currentIndex + preloadRange); i++) {
      ImageLoadingStrategy.loadThumbnail(photoList[i].id, true);
    }
  }
}
```

### 1.3 照片服务层实现

```javascript
// services/image-service.js
const ImageService = {
  // 根据质量级别获取图片
  getImageByQuality(photoId, quality) {
    const photo = this.getPhotoById(photoId);
    if (!photo) return Promise.resolve(null);
    
    // 根据质量级别返回不同路径
    switch(quality) {
      case 'thumbnail':
        return this.getOrGenerateThumbnail(photo);
      case 'medium':
        return this.getOrGenerateMediumImage(photo);
      case 'original':
        return Promise.resolve(photo.path);
      default:
        return Promise.resolve(photo.thumbnailPath || photo.path);
    }
  },
  
  // 获取或生成缩略图
  getOrGenerateThumbnail(photo) {
    if (photo.thumbnailPath) {
      // 已有缩略图，直接返回
      return Promise.resolve(photo.thumbnailPath);
    }
    
    // 生成缩略图
    return this.generateThumbnail(photo.path, photo.id);
  },
  
  // 获取或生成中等分辨率图片
  getOrGenerateMediumImage(photo) {
    if (photo.mediumPath) {
      // 已有中等分辨率图片，直接返回
      return Promise.resolve(photo.mediumPath);
    }
    
    // 生成中等分辨率图片
    return this.generateMediumImage(photo.path, photo.id);
  }
};
``` 