# 弱网环境上传功能服务端适配指南

## 1. 概述

为充分发挥弹性上传组件的功能，服务端需要进行相应的适配，特别是对断点续传和分片上传的支持。本文档提供了服务端适配的关键要点和参考实现方案。

## 2. 服务端功能需求

### 2.1 基础功能

- **接收上传文件**：处理小程序发送的文件上传请求
- **响应标准格式**：返回统一的响应格式，便于小程序处理
- **安全性检查**：验证上传请求的合法性和文件的安全性
- **错误处理**：提供明确的错误信息和状态码

### 2.2 断点续传支持

- **分片合并**：接收并合并文件分片
- **上传状态记录**：维护上传进度和状态信息
- **断点恢复**：支持从特定位置继续上传
- **并发控制**：管理多用户、多文件的并发上传

## 3. API设计

### 3.1 上传接口

**请求方式**：POST
**接口路径**：/api/upload
**Content-Type**：multipart/form-data

**请求参数**：

| 参数名      | 类型    | 必填 | 说明                            |
|------------|---------|------|--------------------------------|
| file       | File    | 是   | 上传的文件                       |
| photoId    | String  | 是   | 照片唯一标识                     |
| quality    | String  | 否   | 照片质量级别(high/medium/low/minimum) |
| timestamp  | Number  | 是   | 上传时间戳                       |
| chunkIndex | Number  | 否   | 分片索引(断点续传时使用)           |
| chunkTotal | Number  | 否   | 分片总数(断点续传时使用)           |
| fileHash   | String  | 否   | 文件哈希值(用于校验)              |

**响应格式**：

```json
{
  "code": 200,
  "message": "上传成功",
  "data": {
    "fileId": "file_123456",
    "url": "https://example.com/uploads/file_123456.jpg",
    "uploadedChunks": [0, 1, 2],  // 已上传的分片索引
    "nextExpectedChunk": 3        // 下一个期望的分片索引
  }
}
```

### 3.2 上传状态查询接口

**请求方式**：GET
**接口路径**：/api/upload/status
**Content-Type**：application/json

**请求参数**：

| 参数名   | 类型    | 必填 | 说明           |
|---------|---------|------|---------------|
| photoId | String  | 是   | 照片唯一标识    |
| fileHash | String | 否   | 文件哈希值      |

**响应格式**：

```json
{
  "code": 200,
  "message": "查询成功",
  "data": {
    "fileId": "file_123456",
    "status": "uploading",  // uploading, completed, failed
    "uploadedChunks": [0, 1, 2],
    "nextExpectedChunk": 3,
    "url": "https://example.com/uploads/file_123456.jpg"  // 如果已完成则提供访问URL
  }
}
```

## 4. 服务端实现建议

### 4.1 分片处理流程

1. **接收分片**：接收单个分片并进行验证
2. **临时存储**：将分片保存到临时目录
3. **记录状态**：更新数据库中的上传状态
4. **判断完成**：检查是否所有分片都已上传
5. **合并文件**：所有分片上传完成后，合并为完整文件
6. **清理临时文件**：合并完成后删除临时分片

### 4.2 断点恢复处理

1. **查询进度**：客户端请求查询已上传分片
2. **返回进度**：服务端返回已上传的分片信息
3. **跳过已传**：客户端跳过已上传的分片，继续上传未完成的部分
4. **续传验证**：验证续传请求的合法性(如时间戳、文件哈希等)

### 4.3 安全性考虑

1. **身份验证**：验证上传请求的用户身份
2. **防盗链**：设置防盗链策略，防止资源被非法访问
3. **文件验证**：检查文件类型、大小和内容安全性
4. **HTTPS传输**：使用HTTPS协议确保传输安全性
5. **访问控制**：设置上传文件的访问权限控制

## 5. 服务端技术栈推荐

### 5.1 Node.js实现

使用Express或Koa框架实现上传服务，优势在于：

- 轻量级，适合微服务架构
- 与小程序技术栈相近，便于开发者理解
- 丰富的文件处理库(如multer、formidable等)

### 5.2 云服务实现

使用云服务提供的对象存储和云函数，如：

- **腾讯云**：云开发+对象存储COS
- **阿里云**：函数计算+对象存储OSS
- **AWS**：Lambda+S3

云服务优势在于无需管理服务器，自动扩展，适合小程序场景。

## 6. 代码参考(以Node.js为例)

### 6.1 接收上传分片

```javascript
const express = require('express');
const multer = require('multer');
const fs = require('fs');
const path = require('path');

const app = express();
const upload = multer({ dest: 'uploads/temp/' });

// 处理分片上传
app.post('/api/upload', upload.single('file'), (req, res) => {
  const { photoId, chunkIndex, chunkTotal, fileHash } = req.body;
  
  // 验证参数
  if (!photoId || chunkIndex === undefined || !chunkTotal) {
    return res.status(400).json({
      code: 400,
      message: '参数不完整',
      data: null
    });
  }
  
  // 创建上传目录
  const uploadDir = path.join(__dirname, 'uploads', photoId);
  if (!fs.existsSync(uploadDir)) {
    fs.mkdirSync(uploadDir, { recursive: true });
  }
  
  // 移动上传的分片到目标文件夹
  const chunkPath = path.join(uploadDir, `chunk_${chunkIndex}`);
  fs.renameSync(req.file.path, chunkPath);
  
  // 更新上传状态
  updateUploadStatus(photoId, chunkIndex, chunkTotal, fileHash);
  
  // 检查是否所有分片都已上传
  const uploadedChunks = getUploadedChunks(photoId);
  const isComplete = uploadedChunks.length === parseInt(chunkTotal);
  
  if (isComplete) {
    // 合并文件
    mergeChunks(photoId, chunkTotal)
      .then(fileUrl => {
        res.json({
          code: 200,
          message: '上传完成',
          data: {
            fileId: photoId,
            url: fileUrl,
            uploadedChunks,
            nextExpectedChunk: -1
          }
        });
      })
      .catch(err => {
        res.status(500).json({
          code: 500,
          message: '合并文件失败',
          data: null
        });
      });
  } else {
    // 返回当前进度
    res.json({
      code: 200,
      message: '分片上传成功',
      data: {
        fileId: photoId,
        uploadedChunks,
        nextExpectedChunk: getNextExpectedChunk(uploadedChunks, chunkTotal)
      }
    });
  }
});
```

### 6.2 查询上传状态

```javascript
app.get('/api/upload/status', (req, res) => {
  const { photoId, fileHash } = req.query;
  
  if (!photoId) {
    return res.status(400).json({
      code: 400,
      message: '参数不完整',
      data: null
    });
  }
  
  // 查询上传状态
  const uploadStatus = getUploadStatus(photoId);
  
  if (!uploadStatus) {
    return res.status(404).json({
      code: 404,
      message: '上传任务不存在',
      data: null
    });
  }
  
  res.json({
    code: 200,
    message: '查询成功',
    data: {
      fileId: photoId,
      status: uploadStatus.status,
      uploadedChunks: uploadStatus.uploadedChunks,
      nextExpectedChunk: getNextExpectedChunk(uploadStatus.uploadedChunks, uploadStatus.chunkTotal),
      url: uploadStatus.status === 'completed' ? getFileUrl(photoId) : null
    }
  });
});
```

## 7. 性能优化建议

1. **分片大小选择**：推荐1MB-5MB的分片大小，平衡传输效率和内存占用
2. **并发控制**：限制单个用户的并发上传数量，避免服务器过载
3. **临时文件清理**：设置定时任务清理过期的临时文件
4. **数据库优化**：为上传状态表添加适当的索引，提高查询效率
5. **CDN加速**：使用CDN分发已上传的文件，提升访问速度
6. **服务水平扩展**：使用负载均衡和多实例部署，提高并发处理能力

## 8. 部署与运维建议

1. **监控告警**：设置服务监控和告警机制，及时发现和处理问题
2. **磁盘空间管理**：定期检查和清理存储空间，避免磁盘空间不足
3. **备份策略**：制定合理的备份策略，确保数据安全
4. **水平扩展**：随着用户增长，适时增加服务器实例
5. **容器化部署**：考虑使用Docker容器化部署，简化环境配置和扩展

## 9. 总结

通过合理设计服务端接口和实现断点续传功能，可以显著提高弱网环境下的上传成功率。开发者应根据实际业务需求和系统规模，选择合适的技术方案，并充分考虑安全性、性能和可扩展性。 