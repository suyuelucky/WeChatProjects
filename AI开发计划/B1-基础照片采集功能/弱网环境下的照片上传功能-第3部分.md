# 弱网环境照片上传功能设计与实现（三）

### 3.2 断点续传上传器核心实现

断点续传上传器的初始化过程中会加载之前保存的上传任务，并设置网络监听，以便在网络状态变化时自动调整上传策略。

```javascript
/**
 * 初始化上传器
 * @returns {Object} 当前实例
 */
init() {
  // 监听网络状态
  this._setupNetworkListener();
  
  // 加载已保存的上传任务
  this._loadPersistedTasks();
  
  console.log('[ResumableUploader] 断点续传上传器初始化完成');
  return this;
}

/**
 * 加载已保存的上传任务
 * @private
 */
_loadPersistedTasks() {
  try {
    const tasksStr = wx.getStorageSync(this._storageKey);
    if (tasksStr) {
      const tasks = JSON.parse(tasksStr);
      this._uploadTasks = tasks || {};
      
      console.log(`[ResumableUploader] 已加载${Object.keys(this._uploadTasks).length}个未完成的上传任务`);
      
      // 检查是否有任务需要恢复
      if (Object.keys(this._uploadTasks).length > 0 && !this._isPaused) {
        // 延迟一段时间再恢复上传，确保应用初始化完成
        setTimeout(() => this.resumeAllUploads(), 5000);
      }
    }
  } catch (err) {
    console.error('[ResumableUploader] 加载任务失败:', err);
    this._uploadTasks = {};
  }
}
```

### 3.3 上传任务的创建与启动

上传任务创建时会生成唯一的任务ID，并将任务保存到任务列表中，如果网络可用，会立即开始上传：

```javascript
/**
 * 创建上传任务
 * @param {Object} fileInfo 文件信息
 * @param {String} url 上传地址
 * @param {Object} options 上传选项
 * @returns {String} 上传任务ID
 */
createUploadTask(fileInfo, url, options = {}) {
  // 安全处理文件名
  const fileName = SecurityFilter.sanitizeFileName(fileInfo.name || 'file_' + Date.now());
  
  // 创建任务ID
  const taskId = 'upload_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
  
  // 创建上传任务
  const task = {
    id: taskId,
    file: {
      ...fileInfo,
      name: fileName
    },
    url: url,
    options: options,
    progress: 0,
    uploaded: 0,
    size: fileInfo.size || 0,
    status: 'pending', // pending, uploading, paused, completed, error
    createTime: Date.now(),
    lastUpdateTime: Date.now(),
    error: null,
    retryCount: 0
  };
  
  // 保存任务
  this._uploadTasks[taskId] = task;
  this._persistTasks();
  
  console.log(`[ResumableUploader] 创建上传任务: ${taskId}`);
  
  // 如果当前网络可用且未暂停，立即开始上传
  if (!this._isPaused && NetworkMonitor.getNetworkState().connected) {
    this._startUpload(taskId);
  }
  
  return taskId;
}
```

### 3.4 上传任务的暂停与恢复

当网络状态不佳或用户主动暂停时，可以暂停上传任务：

```javascript
/**
 * 暂停指定上传任务
 * @param {String} taskId 任务ID
 * @returns {Boolean} 是否成功
 */
pauseUpload(taskId) {
  const task = this._uploadTasks[taskId];
  if (!task || task.status !== 'uploading') {
    return false;
  }
  
  // 如果有活动的上传任务，暂停它
  if (task.uploadTask) {
    try {
      task.uploadTask.abort();
    } catch (err) {
      console.warn(`[ResumableUploader] 中止上传任务出错:`, err);
    }
  }
  
  // 更新任务状态
  task.status = 'paused';
  task.lastUpdateTime = Date.now();
  this._persistTasks();
  
  console.log(`[ResumableUploader] 暂停上传任务: ${taskId}`);
  return true;
}

/**
 * 恢复指定上传任务
 * @param {String} taskId 任务ID
 * @returns {Boolean} 是否成功
 */
resumeUpload(taskId) {
  const task = this._uploadTasks[taskId];
  if (!task || task.status === 'completed' || task.status === 'uploading') {
    return false;
  }
  
  // 如果网络不可用，不恢复上传
  if (!NetworkMonitor.getNetworkState().connected) {
    console.log(`[ResumableUploader] 网络不可用，无法恢复任务: ${taskId}`);
    return false;
  }
  
  // 重新开始上传
  this._startUpload(taskId);
  
  console.log(`[ResumableUploader] 恢复上传任务: ${taskId}`);
  return true;
}
```

## 4. 安全过滤器实现

安全过滤器主要用于处理文件名和图片元数据的安全性，避免敏感信息泄露和安全风险。

### 4.1 文件名安全处理

```javascript
/**
 * 安全处理文件名，移除不安全字符
 * @param {String} fileName 原始文件名
 * @returns {String} 处理后的安全文件名
 */
sanitizeFileName(fileName) {
  if (!fileName) {
    return `file_${Date.now()}`;
  }
  
  // 移除路径分隔符和非法字符
  let safe = fileName.replace(/[\\\/\:\*\?\"\<\>\|]/g, '_');
  
  // 处理特殊字符
  safe = safe.replace(/[\u0000-\u001F\u007F-\u009F]/g, '');
  
  // 限制长度，避免文件名过长
  if (safe.length > 50) {
    const ext = safe.lastIndexOf('.') > 0 ? safe.slice(safe.lastIndexOf('.')) : '';
    safe = safe.slice(0, 50 - ext.length) + ext;
  }
  
  // 确保文件名不为空
  if (!safe || safe.trim() === '') {
    return `file_${Date.now()}`;
  }
  
  return safe;
}
``` 