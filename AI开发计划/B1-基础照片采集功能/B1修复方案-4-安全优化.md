# B1修复方案：安全性优化

## 1. 输入验证与过滤

### 1.1 安全过滤器实现

```javascript
// utils/security-filter.js
const SecurityFilter = {
  // HTML转义：防止XSS攻击
  escapeHTML(input) {
    if (typeof input !== 'string') return input;
    return input
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#x27;');
  },
  
  // 文件名安全化：移除不安全字符，限制长度
  sanitizeFileName(filename) {
    if (!filename) return 'photo_' + Date.now();
    
    // 移除路径操作符和危险字符
    let safe = filename.replace(/[\/\\\.\:\*\?\"\<\>\|]/g, '_');
    
    // 限制长度
    const MAX_LENGTH = 50;
    if (safe.length > MAX_LENGTH) {
      const ext = safe.substring(safe.lastIndexOf('.'));
      safe = safe.substring(0, MAX_LENGTH - ext.length) + ext;
    }
    
    return safe;
  },
  
  // SQL注入防护：转义SQL特殊字符
  escapeSQLString(input) {
    if (typeof input !== 'string') return input;
    return input
      .replace(/'/g, "''")
      .replace(/\\/g, "\\\\")
      .replace(/\0/g, "\\0")
      .replace(/\n/g, "\\n")
      .replace(/\r/g, "\\r")
      .replace(/\t/g, "\\t")
      .replace(/\x1a/g, "\\Z");
  },
  
  // 参数合法性验证
  validateParam(param, rules) {
    if (!rules) return true;
    
    // 类型检查
    if (rules.type && typeof param !== rules.type) {
      return false;
    }
    
    // 字符串长度检查
    if (typeof param === 'string') {
      if (rules.maxLength && param.length > rules.maxLength) {
        return false;
      }
      if (rules.minLength && param.length < rules.minLength) {
        return false;
      }
    }
    
    // 数值范围检查
    if (typeof param === 'number') {
      if (rules.max !== undefined && param > rules.max) {
        return false;
      }
      if (rules.min !== undefined && param < rules.min) {
        return false;
      }
    }
    
    // 正则表达式验证
    if (rules.pattern && typeof param === 'string') {
      const regex = new RegExp(rules.pattern);
      if (!regex.test(param)) {
        return false;
      }
    }
    
    return true;
  },
  
  // 过滤所有用户输入对象的字段
  filterUserInput(inputObject) {
    if (!inputObject || typeof inputObject !== 'object') {
      return inputObject;
    }
    
    const result = {};
    for (const key in inputObject) {
      if (inputObject.hasOwnProperty(key)) {
        const value = inputObject[key];
        
        if (typeof value === 'string') {
          // 字符串类型进行HTML转义
          result[key] = this.escapeHTML(value);
        } else if (Array.isArray(value)) {
          // 数组递归过滤
          result[key] = value.map(item => 
            typeof item === 'string' ? this.escapeHTML(item) : item
          );
        } else {
          // 其他类型保持不变
          result[key] = value;
        }
      }
    }
    
    return result;
  },
  
  // 专门处理前端展示的安全文本
  sanitizeDisplayText(text, maxLength = 100) {
    if (!text) return '';
    
    // 截断长文本
    let sanitized = typeof text === 'string' ? text : String(text);
    if (sanitized.length > maxLength) {
      sanitized = sanitized.substring(0, maxLength) + '...';
    }
    
    // HTML转义
    return this.escapeHTML(sanitized);
  }
};

module.exports = SecurityFilter;
```

### 1.2 全局安全拦截器

```javascript
// app.js - 添加全局请求和输入拦截器
const SecurityFilter = require('./utils/security-filter');

App({
  onLaunch() {
    // 初始化全局安全拦截
    this.setupSecurityInterceptors();
    // ... 其他初始化代码
  },
  
  // 设置安全拦截器
  setupSecurityInterceptors() {
    // 请求拦截器 - 过滤所有向服务器发送的数据
    wx.addInterceptor('request', {
      invoke: (params) => {
        // 如果有请求数据，进行安全过滤
        if (params.data) {
          params.data = SecurityFilter.filterUserInput(params.data);
        }
        return params;
      }
    });
    
    // 上传文件拦截器 - 文件名安全处理
    wx.addInterceptor('uploadFile', {
      invoke: (params) => {
        // 安全处理文件名
        if (params.filePath) {
          const originalPath = params.filePath;
          const lastSlash = originalPath.lastIndexOf('/');
          if (lastSlash >= 0) {
            const fileName = originalPath.substring(lastSlash + 1);
            const safeFileName = SecurityFilter.sanitizeFileName(fileName);
            
            // 更新formData中的文件名
            if (params.formData && params.formData.fileName) {
              params.formData.fileName = safeFileName;
            }
          }
        }
        return params;
      }
    });
  }
});
```

## 2. 照片数据防护

### 2.1 照片元数据净化工具

```javascript
// utils/photo-metadata-cleaner.js
const PhotoMetadataCleaner = {
  // 清理照片元数据，移除潜在敏感信息
  cleanMetadata(photoObject) {
    // 如果不是对象则直接返回
    if (!photoObject || typeof photoObject !== 'object') {
      return photoObject;
    }
    
    // 创建拷贝，避免修改原对象
    const cleanPhoto = { ...photoObject };
    
    // 移除可能包含敏感数据的字段
    const sensitiveFields = [
      'gpsInfo',           // GPS位置信息
      'deviceInfo',        // 详细设备信息
      'originalName',      // 原始文件名
      'creatorInfo',       // 创建者信息
      'editHistory',       // 编辑历史
      'exif'               // 原始EXIF数据
    ];
    
    sensitiveFields.forEach(field => {
      if (cleanPhoto.hasOwnProperty(field)) {
        delete cleanPhoto[field];
      }
    });
    
    // 保留必要的安全元数据
    const safeMetadata = {};
    
    // 仅保留安全必要字段
    if (photoObject.size) safeMetadata.size = photoObject.size;
    if (photoObject.width) safeMetadata.width = photoObject.width;
    if (photoObject.height) safeMetadata.height = photoObject.height;
    if (photoObject.format) safeMetadata.format = photoObject.format;
    if (photoObject.createdAt) safeMetadata.createdAt = photoObject.createdAt;
    
    // 设置安全的元数据
    cleanPhoto.metadata = safeMetadata;
    
    return cleanPhoto;
  },
  
  // 生成安全文件名
  generateSafeFileName(photo) {
    // 使用安全过滤器处理文件名
    const SecurityFilter = require('./security-filter');
    
    // 基于照片ID和时间创建安全文件名
    const baseFileName = `photo_${photo.id || Date.now()}`;
    const safeFileName = SecurityFilter.sanitizeFileName(baseFileName);
    
    return `${safeFileName}.jpg`;
  }
};

module.exports = PhotoMetadataCleaner;
```

### 2.2 安全的照片处理

```javascript
// services/photo-service.js - 增加安全相关方法
const SecurityFilter = require('../utils/security-filter');
const PhotoMetadataCleaner = require('../utils/photo-metadata-cleaner');

// 在PhotoService中添加以下安全处理方法
const PhotoService = {
  // ... 现有方法
  
  /**
   * 安全保存照片数据
   * @param {Object} photo 照片对象
   * @return {Promise<Object>} 安全处理后的照片
   */
  securePhotoSave: function(photo) {
    // 清理照片元数据
    const cleanPhoto = PhotoMetadataCleaner.cleanMetadata(photo);
    
    // 生成安全文件名
    cleanPhoto.safeFileName = PhotoMetadataCleaner.generateSafeFileName(cleanPhoto);
    
    // 如果有描述等用户输入字段，进行安全过滤
    if (cleanPhoto.description) {
      cleanPhoto.description = SecurityFilter.escapeHTML(cleanPhoto.description);
    }
    
    if (cleanPhoto.tags && Array.isArray(cleanPhoto.tags)) {
      cleanPhoto.tags = cleanPhoto.tags.map(tag => 
        SecurityFilter.escapeHTML(tag)
      );
    }
    
    // 验证并限制字段长度
    const MAX_DESCRIPTION_LENGTH = 1000;
    if (cleanPhoto.description && cleanPhoto.description.length > MAX_DESCRIPTION_LENGTH) {
      cleanPhoto.description = cleanPhoto.description.substring(0, MAX_DESCRIPTION_LENGTH);
    }
    
    // 安全保存
    return this.savePhoto(cleanPhoto);
  }
};
```

## 3. 安全规则强制执行

### 3.1 字段验证器

```javascript
// components/photo-input/validators.js
const validators = {
  // 校验照片标题
  validatePhotoTitle(title) {
    if (!title) return { valid: true }; // 允许为空
    
    if (title.length > 50) {
      return {
        valid: false,
        message: '标题不能超过50个字符'
      };
    }
    
    // 检查是否包含危险字符
    const dangerousPattern = /<|>|\/script|on\w+=/i;
    if (dangerousPattern.test(title)) {
      return {
        valid: false,
        message: '标题包含不允许的字符'
      };
    }
    
    return { valid: true };
  },
  
  // 校验照片描述
  validatePhotoDescription(description) {
    if (!description) return { valid: true }; // 允许为空
    
    if (description.length > 1000) {
      return {
        valid: false,
        message: '描述不能超过1000个字符'
      };
    }
    
    return { valid: true };
  },
  
  // 校验照片标签
  validatePhotoTag(tag) {
    if (!tag) return { valid: false, message: '标签不能为空' };
    
    if (tag.length > 20) {
      return {
        valid: false,
        message: '标签不能超过20个字符'
      };
    }
    
    // 只允许字母、数字、中文字符和少量特殊字符
    const validPattern = /^[\u4e00-\u9fa5a-zA-Z0-9_\-\s]+$/;
    if (!validPattern.test(tag)) {
      return {
        valid: false,
        message: '标签只能包含中文、英文、数字和下划线'
      };
    }
    
    return { valid: true };
  }
};

module.exports = validators;
``` 