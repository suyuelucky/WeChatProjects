# 弱网环境照片上传功能设计与实现（六）

## 6. 弹性上传UI组件实现

弹性上传UI组件是对整个弱网环境上传功能的封装，提供了用户友好的界面，包括网络状态显示、上传进度跟踪和操作按钮。

### 6.1 组件初始化与网络监控

```javascript
/**
 * 组件的生命周期
 */
lifetimes: {
  attached() {
    // 初始化上传管理器
    EnhancedUploadManager.init({
      uploadUrl: this.properties.uploadUrl
    });
    
    // 初始化网络监控
    NetworkMonitor.init();
    
    // 监听网络状态变化
    this._setupNetworkMonitor();
    
    // 监听上传事件
    this._setupUploadEvents();
  },
  
  detached() {
    // 取消事件监听
    this._removeEventListeners();
  }
}
```

### 6.2 网络状态变化展示

实时显示网络状态并提供友好提示：

```javascript
/**
 * 显示网络提示
 * @param {Object} state 网络状态
 * @private
 */
_showNetworkTip(state) {
  let tip = '';
  
  if (!state.connected) {
    tip = '网络连接已断开，上传已暂停。恢复连接后将自动继续。';
  } else if (state.networkType === '2g') {
    tip = '当前为2G网络，已启用最低质量上传模式';
  } else if (state.networkType === '3g') {
    tip = '当前为3G网络，已启用低质量上传模式';
  } else if (state.signalStrength === 'weak') {
    tip = '网络信号较弱，已自动降低上传质量';
  }
  
  if (tip) {
    this.setData({
      showNetworkTip: true,
      networkTip: tip
    });
    
    // 3秒后自动隐藏提示
    setTimeout(() => {
      this.setData({
        showNetworkTip: false
      });
    }, 3000);
  }
}
```

### 6.3 上传任务状态管理

组件内部维护了四种类型的照片列表：待上传、上传中、已上传和失败的照片，并提供了相应的状态管理方法。

```javascript
/**
 * 处理上传开始事件
 * @param {Object} data 事件数据
 * @private
 */
_handleUploadStart(data) {
  console.log('[ResilientUploader] 上传开始', data);
  
  // 更新上传状态
  const { pendingPhotos, uploadingPhotos } = this.data;
  
  // 找到对应的待上传照片
  const photoIndex = pendingPhotos.findIndex(p => p.id === data.photoId);
  
  if (photoIndex !== -1) {
    // 从待上传列表中移除
    const photo = pendingPhotos[photoIndex];
    const updatedPending = [...pendingPhotos];
    updatedPending.splice(photoIndex, 1);
    
    // 添加到上传中列表
    const updatedUploading = [...uploadingPhotos, {
      ...photo,
      taskId: data.taskId,
      progress: 0,
      status: 'uploading'
    }];
    
    // 更新状态
    this.setData({
      pendingPhotos: updatedPending,
      uploadingPhotos: updatedUploading,
      isUploading: true
    });
  }
  
  // 触发上传开始事件
  this.triggerEvent('uploadstart', {
    photoId: data.photoId,
    taskId: data.taskId
  });
}
```

### 6.4 照片选择与上传

组件提供了选择照片并上传的方法：

```javascript
/**
 * 选择照片
 */
choosePhoto() {
  // 检查网络是否连接
  if (!this.data.networkState.connected) {
    wx.showToast({
      title: '网络已断开，请先连接网络',
      icon: 'none'
    });
    return;
  }
  
  // 选择图片
  wx.chooseMedia({
    count: this.properties.maxCount,
    mediaType: ['image'],
    sourceType: ['album', 'camera'],
    success: (res) => {
      // 处理选择的照片
      const photos = res.tempFiles.map((file, index) => ({
        id: `photo_${Date.now()}_${index}`,
        path: file.tempFilePath,
        size: file.size,
        type: 'image',
        createTime: Date.now(),
        name: `photo_${Date.now()}_${index}.jpg`,
        status: 'pending',
        progress: 0
      }));
      
      // 更新待上传照片列表
      this.setData({
        pendingPhotos: [...this.data.pendingPhotos, ...photos]
      });
      
      // 触发照片选择事件
      this.triggerEvent('photochoose', {
        photos: photos
      });
      
      // 如果设置了自动上传，则开始上传
      if (this.properties.autoUpload) {
        this.startUpload();
      }
    }
  });
}
```

## 7. 弱网环境上传最佳实践

### 7.1 任务持久化

在微信小程序中，上传任务的持久化是提高用户体验的关键。应用可能在任何时候被关闭或者小程序被切换到后台，因此需要：

1. 使用 `wx.setStorageSync` 保存上传任务状态
2. 在应用启动时检查并恢复未完成的上传任务
3. 定期更新任务状态以避免数据丢失

```javascript
// 保存任务状态
_persistTasks() {
  try {
    // 过滤掉已完成的任务，只保存未完成的
    const tasks = {};
    Object.keys(this._uploadTasks).forEach(taskId => {
      const task = this._uploadTasks[taskId];
      if (task.status !== 'completed') {
        tasks[taskId] = task;
      }
    });
    
    wx.setStorageSync(this._storageKey, JSON.stringify(tasks));
  } catch (err) {
    console.error('[ResumableUploader] 保存任务失败:', err);
  }
}
```

### 7.2 网络自适应策略

根据不同的网络环境，采取不同的上传策略：

| 网络类型 | 质量级别 | 并发数 | 重试间隔 |
| -------- | -------- | ------ | -------- |
| WiFi     | 高       | 3      | 1秒      |
| 4G       | 中等     | 2      | 2秒      |
| 3G       | 低       | 1      | 3秒      |
| 2G       | 最低     | 1      | 5秒      |

### 7.3 错误处理与重试

实现指数退避算法，避免过于频繁的重试：

```javascript
// 如果上传失败，延迟重试
if (task.retryCount < (task.options.maxRetries || 3)) {
  console.log(`[ResumableUploader] 准备第${task.retryCount}次重试: ${taskId}`);
  
  // 延迟重试，时间随重试次数增加
  setTimeout(() => {
    if (this._uploadTasks[taskId] && NetworkMonitor.getNetworkState().connected) {
      this._startUpload(taskId);
    }
  }, (task.options.retryDelay || 3000) * task.retryCount);
}
``` 