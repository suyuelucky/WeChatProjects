# 数据冲突解决规范

> **强制标准**: 本文档定义了A4数据同步框架中数据冲突的检测和解决规范，所有冲突解决实现必须严格遵循此规范，不允许任何偏离。

## 概述

数据冲突是分布式数据同步系统中的关键挑战，尤其在多设备、弱网络环境下尤为常见。A4数据同步框架采用系统化的冲突检测和解决策略，确保数据一致性、完整性和可靠性。

## 冲突定义

### 冲突类型

1. **更新冲突**: 同一数据项在客户端和服务器端同时被修改
   - 例: 用户A和用户B同时修改同一条记录的标题字段

2. **删除冲突**: 一方删除而另一方修改同一数据项
   - 例: 用户A删除记录，而用户B修改该记录内容

3. **插入冲突**: 使用相同ID插入不同内容
   - 例: 两个设备同时创建新记录并分配了相同ID

4. **结构冲突**: 同一数据项结构定义不一致
   - 例: 本地数据使用旧结构，服务器已升级到新结构

5. **引用冲突**: 引用已被删除或修改的数据
   - 例: 引用已被其他用户删除的资源

### 冲突元数据

每个冲突包含以下元数据：

```json
{
  "id": "冲突唯一标识符",
  "type": "冲突类型(update|delete|insert|structure|reference)",
  "path": "数据路径",
  "timestamp": 1617687042000,
  "clientData": {
    "value": "客户端数据值",
    "version": "客户端数据版本",
    "timestamp": 1617686042000,
    "deviceId": "设备标识符",
    "userId": "用户标识符"
  },
  "serverData": {
    "value": "服务器数据值",
    "version": "服务器数据版本",
    "timestamp": 1617686142000,
    "deviceId": "最后修改设备标识符",
    "userId": "最后修改用户标识符"
  },
  "resolution": {
    "strategy": "应用的解决策略",
    "value": "解决后的值",
    "version": "解决后的版本",
    "timestamp": 1617687042000,
    "automatic": true // 是否自动解决
  }
}
```

## 冲突检测

### 基于版本的检测

```javascript
/**
 * 基于版本的冲突检测
 * 
 * @param {Object} localData 本地数据
 * @param {Object} serverData 服务器数据
 * @returns {boolean} 是否存在冲突
 */
function detectVersionConflict(localData, serverData) {
  // 如果本地版本基于服务器先前版本，则存在冲突
  if (localData.baseVersion !== serverData.version) {
    return true;
  }
  return false;
}
```

### 基于时间戳的检测

```javascript
/**
 * 基于时间戳的冲突检测
 * 
 * @param {Object} localData 本地数据
 * @param {Object} serverData 服务器数据
 * @param {number} syncThreshold 同步阈值(毫秒)
 * @returns {boolean} 是否存在冲突
 */
function detectTimestampConflict(localData, serverData, syncThreshold) {
  // 默认阈值为1分钟
  syncThreshold = syncThreshold || 60000;
  
  // 计算修改时间差异
  var timeDiff = Math.abs(localData.modifiedAt - serverData.modifiedAt);
  
  // 如果两次修改时间接近，可能存在冲突
  if (timeDiff < syncThreshold) {
    // 进一步检查数据内容
    return !deepEqual(localData.value, serverData.value);
  }
  
  return false;
}
```

### 基于内容的检测

```javascript
/**
 * 基于内容的冲突检测
 * 
 * @param {Object} localData 本地数据
 * @param {Object} serverData 服务器数据
 * @param {Object} baseData 基准数据(上次同步时的数据)
 * @returns {boolean} 是否存在冲突
 */
function detectContentConflict(localData, serverData, baseData) {
  // 计算本地与基准的差异
  var localChanges = calculateDiff(baseData, localData);
  
  // 计算服务器与基准的差异
  var serverChanges = calculateDiff(baseData, serverData);
  
  // 检查是否有重叠的修改路径
  for (var path in localChanges) {
    if (serverChanges.hasOwnProperty(path)) {
      return true;
    }
  }
  
  return false;
}
```

## 冲突解决策略

### 内置策略

#### 1. 服务器优先策略

```javascript
/**
 * 服务器优先策略
 * 冲突时优先采用服务器端数据
 * 
 * @param {Object} conflict 冲突数据
 * @returns {Object} 解决后的数据
 */
function serverWinsStrategy(conflict) {
  return {
    value: conflict.serverData.value,
    version: generateNewVersion(conflict.serverData.version),
    timestamp: Date.now(),
    source: 'conflict-resolution',
    baseVersion: conflict.serverData.version
  };
}
```

#### 2. 客户端优先策略

```javascript
/**
 * 客户端优先策略
 * 冲突时优先采用客户端数据
 * 
 * @param {Object} conflict 冲突数据
 * @returns {Object} 解决后的数据
 */
function clientWinsStrategy(conflict) {
  return {
    value: conflict.clientData.value,
    version: generateNewVersion(conflict.serverData.version),
    timestamp: Date.now(),
    source: 'conflict-resolution',
    baseVersion: conflict.serverData.version
  };
}
```

#### 3. 最新时间戳策略

```javascript
/**
 * 最新时间戳策略
 * 采用时间戳较新的数据
 * 
 * @param {Object} conflict 冲突数据
 * @returns {Object} 解决后的数据
 */
function lastWriteWinsStrategy(conflict) {
  var useClientData = conflict.clientData.timestamp > conflict.serverData.timestamp;
  
  return {
    value: useClientData ? conflict.clientData.value : conflict.serverData.value,
    version: generateNewVersion(conflict.serverData.version),
    timestamp: Date.now(),
    source: 'conflict-resolution',
    baseVersion: conflict.serverData.version
  };
}
```

#### 4. 智能合并策略

```javascript
/**
 * 智能合并策略
 * 尝试合并两个版本的变更
 * 
 * @param {Object} conflict 冲突数据
 * @param {Object} baseData 基准数据(上次同步的数据)
 * @returns {Object} 解决后的数据
 */
function smartMergeStrategy(conflict, baseData) {
  try {
    // 计算各自相对于基准数据的变化
    var clientChanges = calculateDiff(baseData, conflict.clientData.value);
    var serverChanges = calculateDiff(baseData, conflict.serverData.value);
    
    // 创建合并结果的副本
    var mergedValue = JSON.parse(JSON.stringify(baseData));
    
    // 应用不冲突的变化
    for (var path in clientChanges) {
      if (!serverChanges.hasOwnProperty(path)) {
        applyChange(mergedValue, path, clientChanges[path]);
      }
    }
    
    for (var path in serverChanges) {
      if (!clientChanges.hasOwnProperty(path)) {
        applyChange(mergedValue, path, serverChanges[path]);
      } else {
        // 处理冲突字段 - 这里使用服务器值作为示例
        // 在实际实现中可以有更复杂的策略
        applyChange(mergedValue, path, serverChanges[path]);
      }
    }
    
    return {
      value: mergedValue,
      version: generateNewVersion(conflict.serverData.version),
      timestamp: Date.now(),
      source: 'conflict-resolution',
      baseVersion: conflict.serverData.version
    };
  } catch (error) {
    // 如果合并失败，回退到服务器优先策略
    return serverWinsStrategy(conflict);
  }
}
```

#### 5. 自定义策略接口

```javascript
/**
 * 自定义冲突解决策略接口
 * 
 * @interface IConflictResolver
 */
var IConflictResolver = {
  /**
   * 初始化解决器
   * @param {Object} options 配置选项
   * @returns {Promise} 初始化完成的Promise
   */
  init: function(options) {},
  
  /**
   * 判断是否存在冲突
   * @param {Object} localData 本地数据
   * @param {Object} serverData 服务器数据
   * @param {Object} baseData 基准数据
   * @returns {Promise<boolean>} 是否存在冲突
   */
  hasConflict: function(localData, serverData, baseData) {},
  
  /**
   * 解决冲突
   * @param {Object} conflict 冲突数据
   * @returns {Promise<Object>} 解决后的数据
   */
  resolveConflict: function(conflict) {},
  
  /**
   * 销毁解决器
   * @returns {Promise}
   */
  destroy: function() {}
};
```

## 冲突解决流程

### 自动解决流程

```
┌─────────────┐     ┌─────────────┐     ┌────────────────┐
│  检测冲突   │────►│ 应用解决策略 │────►│  生成解决结果  │
└─────────────┘     └─────────────┘     └────────────────┘
                          │
                          │ 无法自动解决
                          ▼
                    ┌─────────────┐     ┌────────────────┐
                    │  标记冲突   │────►│ 通知应用程序   │
                    └─────────────┘     └────────────────┘
```

### 手动解决流程

```
┌─────────────┐     ┌─────────────┐     ┌────────────────┐
│ 应用收到冲突│────►│ 展示冲突UI  │────►│ 用户选择解决方案│
└─────────────┘     └─────────────┘     └────────────────┘
                                               │
                                               ▼
                                        ┌────────────────┐
                                        │ 应用解决策略   │
                                        └────────────────┘
                                               │
                                               ▼
                                        ┌────────────────┐
                                        │ 提交解决结果   │
                                        └────────────────┘
```

## 具体实现示例

### 冲突解决器实现

```javascript
/**
 * 冲突解决器
 * @implements {IConflictResolver}
 */
var ConflictResolver = {
  // 内部状态
  _options: null,
  _initialized: false,
  
  // 默认选项
  defaultOptions: {
    /**
     * 默认解决策略
     * @type {string}
     * @enum {server-wins|client-wins|last-write-wins|smart-merge}
     */
    defaultStrategy: 'server-wins',
    
    /**
     * 按路径配置解决策略
     * @type {Object}
     */
    pathStrategies: {},
    
    /**
     * 是否自动解决所有冲突
     * @type {boolean}
     */
    autoResolveAll: true,
    
    /**
     * 允许手动解决的冲突类型
     * @type {Array<string>}
     */
    manualResolveTypes: ['structure', 'reference']
  },
  
  /**
   * 初始化解决器
   */
  init: function(options) {
    var self = this;
    return new Promise(function(resolve, reject) {
      try {
        self._options = Object.assign({}, self.defaultOptions, options || {});
        self._initialized = true;
        resolve();
      } catch (error) {
        reject(error);
      }
    });
  },
  
  /**
   * 判断是否存在冲突
   */
  hasConflict: function(localData, serverData, baseData) {
    if (!this._initialized) {
      return Promise.reject(new Error('ConflictResolver not initialized'));
    }
    
    return new Promise(function(resolve) {
      var hasVersionConflict = detectVersionConflict(localData, serverData);
      if (hasVersionConflict) {
        return resolve(true);
      }
      
      var hasContentConflict = detectContentConflict(localData, serverData, baseData);
      resolve(hasContentConflict);
    });
  },
  
  /**
   * 解决冲突
   */
  resolveConflict: function(conflict) {
    if (!this._initialized) {
      return Promise.reject(new Error('ConflictResolver not initialized'));
    }
    
    var self = this;
    return new Promise(function(resolve, reject) {
      try {
        // 检查是否应手动解决
        if (!self._options.autoResolveAll && 
            self._options.manualResolveTypes.indexOf(conflict.type) >= 0) {
          // 标记为需要手动解决
          var manualResult = {
            needsManualResolution: true,
            conflict: conflict
          };
          return resolve(manualResult);
        }
        
        // 获取适用的策略
        var strategyName = self._getStrategyForPath(conflict.path);
        var resolved;
        
        // 应用策略
        switch (strategyName) {
          case 'server-wins':
            resolved = serverWinsStrategy(conflict);
            break;
          case 'client-wins':
            resolved = clientWinsStrategy(conflict);
            break;
          case 'last-write-wins':
            resolved = lastWriteWinsStrategy(conflict);
            break;
          case 'smart-merge':
            resolved = smartMergeStrategy(conflict, conflict.baseData);
            break;
          default:
            resolved = serverWinsStrategy(conflict); // 默认回退策略
        }
        
        // 构建结果
        var result = {
          value: resolved.value,
          version: resolved.version,
          timestamp: resolved.timestamp,
          resolution: {
            strategy: strategyName,
            timestamp: Date.now(),
            automatic: true
          }
        };
        
        resolve(result);
      } catch (error) {
        reject(error);
      }
    });
  },
  
  /**
   * 获取特定路径的解决策略
   * @private
   */
  _getStrategyForPath: function(path) {
    if (!this._options.pathStrategies) {
      return this._options.defaultStrategy;
    }
    
    // 检查是否有精确匹配的路径策略
    if (this._options.pathStrategies[path]) {
      return this._options.pathStrategies[path];
    }
    
    // 检查是否有匹配的路径前缀
    for (var prefix in this._options.pathStrategies) {
      if (path.startsWith(prefix)) {
        return this._options.pathStrategies[prefix];
      }
    }
    
    // 返回默认策略
    return this._options.defaultStrategy;
  },
  
  /**
   * 销毁解决器
   */
  destroy: function() {
    this._initialized = false;
    this._options = null;
    return Promise.resolve();
  }
};
```

### 使用示例

```javascript
// 初始化A4Sync时配置冲突解决策略
var syncManager = new A4Sync({
  conflictResolution: {
    defaultStrategy: 'last-write-wins',
    pathStrategies: {
      'userProfile': 'client-wins',      // 用户个人资料优先采用本地数据
      'sharedDocuments': 'server-wins',  // 共享文档优先采用服务器数据
      'forms/': 'smart-merge'            // 表单数据尝试智能合并
    },
    autoResolveAll: false,               // 允许手动解决某些冲突
    manualResolveTypes: ['structure']    // 结构冲突需手动解决
  }
});

// 注册冲突处理函数
syncManager.on('conflict', function(conflict) {
  if (conflict.needsManualResolution) {
    // 展示UI让用户解决冲突
    showConflictUI(conflict, function(resolution) {
      // 用户选择后提交解决方案
      syncManager.resolveConflict(conflict.id, resolution);
    });
  } else {
    console.log('冲突已自动解决:', conflict.resolution);
  }
});

// 手动设置特定同步请求的冲突策略
syncManager.sync({
  conflictStrategy: 'client-wins' // 本次同步优先采用本地数据
});
```

## 冲突预防策略

除了解决冲突外，A4框架还提供以下冲突预防机制：

### 1. 乐观锁机制

```javascript
// 编辑前获取数据和锁
syncManager.lockForEdit('document/123')
  .then(function(document) {
    // 展示编辑UI
    showEditor(document, function(updatedDocument) {
      // 保存时包含锁信息
      syncManager.saveWithLock('document/123', updatedDocument)
        .then(function() {
          console.log('保存成功');
        })
        .catch(function(error) {
          if (error.code === 'LOCK_EXPIRED') {
            console.error('锁已过期，可能已被他人修改');
          }
        });
    });
  });
```

### 2. 合作感知机制

```javascript
// 注册实时协作状态监听
syncManager.subscribeCollaboration('document/123', function(status) {
  if (status.activeUsers.length > 1) {
    // 显示其他用户正在编辑的警告
    showCollaborationWarning(status.activeUsers);
  }
});

// 更新协作状态
syncManager.updateCollaborationStatus('document/123', {
  action: 'editing',
  section: 'title'
});
```

### 3. 定期自动同步

```javascript
// 编辑过程中定期自动同步草稿
var autoSyncId = syncManager.startAutoSync('document/123', {
  interval: 30000, // 30秒
  saveDraft: true
});

// 完成编辑后停止自动同步
syncManager.stopAutoSync(autoSyncId);
```

## 数据一致性验证

为确保冲突解决后数据的一致性，A4框架提供以下验证机制：

### 1. 结构验证

```javascript
/**
 * 结构验证器配置
 */
var schemaValidator = {
  'userProfile': {
    type: 'object',
    required: ['id', 'name'],
    properties: {
      id: { type: 'string' },
      name: { type: 'string' },
      email: { type: 'string', format: 'email' },
      age: { type: 'number', minimum: 0 }
    }
  }
};

// 配置验证器
syncManager.setSchemaValidator(schemaValidator);
```

### 2. 业务规则验证

```javascript
/**
 * 业务规则验证器
 */
syncManager.setBusinessRules({
  'orders': function(data) {
    // 订单总价必须等于商品价格总和
    var total = data.total;
    var itemsTotal = data.items.reduce(function(sum, item) {
      return sum + (item.price * item.quantity);
    }, 0);
    
    if (Math.abs(total - itemsTotal) > 0.01) {
      return {
        valid: false,
        error: '订单总价不匹配'
      };
    }
    
    return { valid: true };
  }
});
```

### 3. 关系完整性验证

```javascript
/**
 * 关系完整性验证器
 */
syncManager.setRelationshipValidator({
  'orderItems': {
    foreignKeys: [{
      field: 'productId',
      references: 'products',
      onDelete: 'restrict'
    }]
  }
});
```

## 验收标准

冲突解决实现必须满足以下验收标准：

1. **功能完整性**: 实现所有规定的冲突检测和解决策略
2. **正确性**: 在所有测试场景中正确检测和解决冲突
3. **性能要求**: 冲突检测和解决操作必须高效，不引入明显延迟
4. **健壮性**: 处理各种边缘情况和异常输入
5. **扩展性**: 支持自定义冲突检测和解决策略
6. **用户体验**: 提供良好的冲突解决反馈机制
7. **数据完整性**: 确保冲突解决后数据满足一致性要求
8. **兼容性**: 与框架其他组件协同工作

## 测试要求

每个冲突解决实现必须通过以下测试：

1. **冲突检测测试**: 验证各种冲突类型的正确检测
2. **解决策略测试**: 验证各种解决策略的正确行为
3. **边界条件测试**: 测试极端数据大小、复杂嵌套结构等
4. **错误处理测试**: 验证错误输入的正确处理
5. **性能测试**: 测试大量冲突时的性能表现
6. **集成测试**: 验证与同步流程的集成表现 