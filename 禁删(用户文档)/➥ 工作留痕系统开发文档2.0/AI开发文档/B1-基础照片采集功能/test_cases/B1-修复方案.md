# B1-基础照片采集功能 - 修复方案

本文档提供针对"B1-极端测试报告"中发现的问题的具体修复方案，包括代码示例和实现指南。

## 1. 高优先级修复

### 1.1 ES5兼容性改进

#### camera-manager.js 兼容性修复

```javascript
// 原代码 (使用箭头函数):
setTimeout(() => {
  TaskManager.checkInterruptedTasks();
}, 3000);

// 修改后 (使用ES5兼容的函数表达式):
setTimeout(function() {
  TaskManager.checkInterruptedTasks();
}, 3000);

// 原代码 (使用模板字符串):
console.log(`[UploadManager] 已设置上传质量: ${level}`);

// 修改后 (使用字符串连接):
console.log('[UploadManager] 已设置上传质量: ' + level);
```

#### 所有组件通用修复指南

1. 替换所有箭头函数
2. 替换所有模板字符串
3. 避免使用解构赋值，改用传统对象属性访问
4. 替换ES6+的方法（如Array.prototype.includes）为兼容方法

### 1.2 内存泄漏风险修复

#### camera-manager.js 生命周期完善

```javascript
lifetimes: {
  attached: function() {
    // 现有代码...
    
    // 记录用于清理的引用
    this._eventListeners = [];
  },
  
  detached: function() {
    // 清理资源
    this.stopContinuousCapture();
    this.stopCountdown();
    
    // 清理照片列表
    this.clearPhotoList();
    
    // 清理事件监听
    if (this._eventListeners && this._eventListeners.length) {
      this._eventListeners.forEach(function(listener) {
        EventBus.off(listener.event, listener.callback);
      });
      this._eventListeners = [];
    }
    
    // 释放相机上下文
    this.cameraContext = null;
  }
}

// 添加事件监听的通用方法
_addEventListenerWithCleanup: function(event, callback) {
  EventBus.on(event, callback);
  
  // 记录以便清理
  if (!this._eventListeners) {
    this._eventListeners = [];
  }
  this._eventListeners.push({
    event: event,
    callback: callback
  });
}
```

### 1.3 照片上传服务URL配置问题修复

#### 使用配置文件管理服务URL

创建配置文件: `/miniprogram/config/api.config.js`

```javascript
/**
 * API配置文件
 * 根据环境变量切换不同的服务地址
 */
var env = {
  dev: 'development',
  test: 'testing',
  prod: 'production'
};

// 当前环境，可通过构建过程修改
var currentEnv = env.dev; 

// 各环境的API服务地址
var apiBase = {
  development: 'https://dev-api.example.com',
  testing: 'https://test-api.example.com',
  production: 'https://api.example.com'
};

// API路径配置
var apiPath = {
  photoUpload: '/api/photos/upload'
};

// 将所有配置导出
module.exports = {
  // 获取完整的API URL
  getApiUrl: function(apiName) {
    var base = apiBase[currentEnv];
    var path = apiPath[apiName] || '';
    return base + path;
  },
  
  // 当前环境
  currentEnv: currentEnv,
  
  // 设置环境
  setEnv: function(env) {
    if (apiBase[env]) {
      currentEnv = env;
    }
  }
};
```

修改 `upload-manager.js` 中的URL配置:

```javascript
// 引入配置
var ApiConfig = require('../../config/api.config');

// 修改初始化方法
init() {
  // 初始化网络监听
  this.setupNetworkMonitor();
  
  // 使用配置文件的API URL
  this.uploadUrl = ApiConfig.getApiUrl('photoUpload');
  
  console.log('[UploadManager] 上传管理器初始化完成，上传地址: ' + this.uploadUrl);
}
```

## 2. 中优先级修复

### 2.1 错误处理完善

#### 添加错误类型分类和处理

在camera-manager.js中添加错误处理逻辑:

```javascript
/**
 * 处理相机错误
 */
handleCameraError: function(e) {
  var errorDetail = e.detail || {};
  var errorCode = errorDetail.errCode || -1;
  var errorMessage = errorDetail.errMsg || '未知错误';
  
  console.error('Camera error:', errorDetail);
  
  // 错误分类处理
  switch(errorCode) {
    case 10001: // 示例：相机硬件错误
      this._handleHardwareError(errorMessage);
      break;
    case 10002: // 示例：相机被占用
      this._handleCameraOccupiedError(errorMessage);
      break;
    case 10003: // 示例：相机初始化失败
      this._handleInitializationError(errorMessage);
      break;
    default:
      this._handleGeneralError(errorMessage);
  }
  
  this.triggerEvent('cameraError', {
    error: errorDetail,
    handled: true
  });
},

/**
 * 处理硬件相关错误
 * @private
 */
_handleHardwareError: function(errMsg) {
  wx.showModal({
    title: '相机硬件异常',
    content: '请检查您的相机硬件是否正常工作，或尝试重启设备。',
    showCancel: false
  });
},

/**
 * 处理相机被占用错误
 * @private
 */
_handleCameraOccupiedError: function(errMsg) {
  wx.showModal({
    title: '相机被占用',
    content: '相机可能被其他应用占用，请关闭相关应用后重试。',
    showCancel: false
  });
},

/**
 * 处理初始化错误
 * @private
 */
_handleInitializationError: function(errMsg) {
  wx.showModal({
    title: '相机初始化失败',
    content: '初始化相机时出现问题，请退出后重新进入。',
    confirmText: '重试',
    success: (res) => {
      if (res.confirm) {
        // 重新初始化相机
        this.initCamera();
      }
    }
  });
},

/**
 * 处理一般错误
 * @private
 */
_handleGeneralError: function(errMsg) {
  wx.showToast({
    title: '相机出现问题',
    icon: 'none',
    duration: 2000
  });
}
```

### 2.2 网络异常重试机制

在upload-manager.js中添加网络错误重试逻辑:

```javascript
/**
 * 上传照片文件
 * @param {Object} task 上传任务
 * @param {Number} retryCount 重试次数
 */
uploadPhotoFile: function(task, retryCount) {
  // 默认重试次数
  var maxRetries = 3;
  var currentRetry = retryCount || 0;
  
  // 更新任务状态
  TaskManager.updateTaskStatus(task.id, 'uploading');
  
  // 创建uploadTask
  var uploadTask = wx.uploadFile({
    url: this.uploadUrl,
    filePath: task.data.tempFilePath,
    name: 'photo',
    formData: {
      'photoId': task.data.photoId,
      'createTime': task.data.createTime
    },
    success: (res) => {
      try {
        // 解析响应
        var response = JSON.parse(res.data);
        
        if (response.success) {
          // 更新任务状态为完成
          TaskManager.updateTaskStatus(task.id, 'completed', response);
          console.log('[UploadManager] 照片上传成功:', task.id);
        } else {
          console.error('[UploadManager] 服务器返回错误:', response.message);
          
          // 更新任务状态为失败
          TaskManager.updateTaskStatus(task.id, 'failed', {
            error: response.message || '服务器返回错误'
          });
          
          // 根据错误类型判断是否重试
          var shouldRetry = response.code !== 'INVALID_PHOTO';
          
          if (shouldRetry && currentRetry < maxRetries) {
            console.log('[UploadManager] 准备重试上传:', task.id, '第', (currentRetry + 1), '次');
            
            // 延迟重试，时间递增
            setTimeout(() => {
              this.uploadPhotoFile(task, currentRetry + 1);
            }, (currentRetry + 1) * 2000);
          }
        }
      } catch (e) {
        console.error('[UploadManager] 解析响应失败:', e);
        
        // 更新任务状态为失败
        TaskManager.updateTaskStatus(task.id, 'failed', {
          error: '解析响应失败'
        });
        
        // 重试
        if (currentRetry < maxRetries) {
          setTimeout(() => {
            this.uploadPhotoFile(task, currentRetry + 1);
          }, (currentRetry + 1) * 2000);
        }
      }
    },
    fail: (err) => {
      console.error('[UploadManager] 上传失败:', err);
      
      // 检查是否是网络错误
      var isNetworkError = err.errMsg && (
        err.errMsg.indexOf('timeout') !== -1 ||
        err.errMsg.indexOf('disconnect') !== -1 ||
        err.errMsg.indexOf('network') !== -1
      );
      
      // 更新任务状态
      TaskManager.updateTaskStatus(task.id, 'failed', {
        error: err.errMsg || '上传失败',
        isNetworkError: isNetworkError
      });
      
      // 网络错误时自动重试
      if (isNetworkError && currentRetry < maxRetries) {
        console.log('[UploadManager] 网络错误，准备重试:', task.id, '第', (currentRetry + 1), '次');
        
        // 延迟重试，时间递增
        setTimeout(() => {
          this.uploadPhotoFile(task, currentRetry + 1);
        }, (currentRetry + 1) * 3000); // 网络错误重试间隔更长
      }
    }
  });
  
  // 保存uploadTask实例以便控制
  this.uploadTaskMap[task.id] = uploadTask;
  
  // 设置上传进度回调
  uploadTask.onProgressUpdate((res) => {
    // 更新上传进度
    TaskManager.updateTaskProgress(task.id, res.progress);
  });
}
```

### 2.3 权限管理增强

在camera-manager.js中完善权限管理:

```javascript
/**
 * 检查相机权限
 * @private
 */
checkCameraPermission: function() {
  var that = this;
  
  // 首先从存储中读取权限状态
  wx.getStorage({
    key: 'camera_permission_status',
    success: function(res) {
      // 如果曾经被永久拒绝，直接显示引导
      if (res.data === 'permanently_denied') {
        that.showPermissionGuide(true);
        return;
      }
      
      // 否则检查当前权限
      that.checkCurrentPermission();
    },
    fail: function() {
      // 没有记录，检查当前权限
      that.checkCurrentPermission();
    }
  });
},

/**
 * 检查当前相机权限
 * @private
 */
checkCurrentPermission: function() {
  var that = this;
  
  wx.getSetting({
    success: function(res) {
      if (res.authSetting['scope.camera']) {
        // 已授权
        that.setData({
          hasPermission: true
        });
        
        // 保存权限状态
        wx.setStorage({
          key: 'camera_permission_status',
          data: 'granted'
        });
        
        // 初始化相机
        that.initCamera();
      } else if (res.authSetting['scope.camera'] === false) {
        // 已拒绝授权，标记为永久拒绝
        wx.setStorage({
          key: 'camera_permission_status',
          data: 'permanently_denied'
        });
        
        that.setData({
          hasPermission: false
        });
        
        // 显示永久权限引导
        that.showPermissionGuide(true);
        
        // 触发权限拒绝事件
        that.triggerEvent('permissionDenied', { isPermanent: true });
      } else {
        // 首次使用，请求授权
        wx.authorize({
          scope: 'scope.camera',
          success: function() {
            that.setData({
              hasPermission: true
            });
            
            // 保存权限状态
            wx.setStorage({
              key: 'camera_permission_status',
              data: 'granted'
            });
            
            // 初始化相机
            that.initCamera();
          },
          fail: function() {
            that.setData({
              hasPermission: false
            });
            
            // 保存权限状态
            wx.setStorage({
              key: 'camera_permission_status',
              data: 'denied'
            });
            
            // 显示临时权限引导
            that.showPermissionGuide(false);
            
            // 触发权限拒绝事件
            that.triggerEvent('permissionDenied', { isPermanent: false });
          }
        });
      }
    }
  });
},

/**
 * 显示权限引导界面
 * @param {Boolean} isPermanent 是否永久拒绝
 * @private
 */
showPermissionGuide: function(isPermanent) {
  this.setData({
    hasPermission: false,
    isPermanentlyDenied: isPermanent
  });
}
```

在camera-manager.wxml中增加权限界面:

```html
<view class="permission-denied" wx:if="{{!hasPermission}}">
  <view class="permission-icon">
    <text class="icon-camera"></text>
  </view>
  <view class="permission-text">无法访问相机</view>
  
  <!-- 不同拒绝情况显示不同内容 -->
  <block wx:if="{{isPermanentlyDenied}}">
    <view class="permission-tips">您已拒绝相机权限，请在设置中手动允许微信使用相机</view>
    <button class="permission-button" open-type="openSetting">前往设置</button>
  </block>
  <block wx:else>
    <view class="permission-tips">需要相机权限才能拍摄照片</view>
    <button class="permission-button" bindtap="requestPermissionAgain">重新获取权限</button>
  </block>
</view>
```

添加方法:

```javascript
/**
 * 再次请求权限
 */
requestPermissionAgain: function() {
  wx.authorize({
    scope: 'scope.camera',
    success: () => {
      this.setData({
        hasPermission: true
      });
      
      // 保存权限状态
      wx.setStorage({
        key: 'camera_permission_status',
        data: 'granted'
      });
      
      // 初始化相机
      this.initCamera();
    },
    fail: () => {
      // 显示提示
      wx.showModal({
        title: '权限申请',
        content: '相机权限申请失败，请在设置中手动开启',
        confirmText: '前往设置',
        success: (res) => {
          if (res.confirm) {
            wx.openSetting();
          }
        }
      });
    }
  });
}
```

## 3. 性能优化措施

### 3.1 照片处理分批优化

在PhotoService.js中改进照片批量处理:

```javascript
/**
 * 分批处理照片
 * @param {Array} photos 照片列表
 * @param {Number} batchSize 每批处理数量
 * @return {Promise<Array>} 保存的照片
 */
batchProcessPhotos: function(photos, batchSize) {
  if (!Array.isArray(photos) || photos.length === 0) {
    return Promise.resolve([]);
  }
  
  // 默认批次大小
  var size = batchSize || 5;
  var processedPhotos = [];
  var totalCount = photos.length;
  var currentIndex = 0;
  
  // 返回一个Promise，在所有批次处理完成后解析
  return new Promise((resolve, reject) => {
    // 处理单个批次
    var processBatch = function() {
      // 计算当前批次结束索引
      var endIndex = Math.min(currentIndex + size, totalCount);
      var currentBatch = photos.slice(currentIndex, endIndex);
      
      // 处理当前批次
      Promise.all(currentBatch.map(function(photo) {
        return this.processPhoto(photo);
      }, this))
      .then(function(results) {
        // 添加到已处理列表
        processedPhotos = processedPhotos.concat(results);
        
        // 更新进度
        var progress = Math.round((endIndex / totalCount) * 100);
        console.log('照片处理进度:', progress + '%');
        
        // 触发进度事件
        EventBus.emit('photo:process:progress', {
          processed: endIndex,
          total: totalCount,
          progress: progress
        });
        
        // 继续处理下一批
        currentIndex = endIndex;
        if (currentIndex < totalCount) {
          // 使用setTimeout避免长时间阻塞UI
          setTimeout(processBatch, 50);
        } else {
          // 所有批次处理完成
          resolve(processedPhotos);
        }
      })
      .catch(function(err) {
        reject(err);
      });
    };
    
    // 开始处理第一批
    processBatch();
  });
},

/**
 * 处理单个照片
 * @param {Object} photo 照片对象
 * @return {Promise<Object>} 处理后的照片
 * @private
 */
processPhoto: function(photo) {
  // 获取存储服务
  var storageService = this.container.get('storageService');
  
  // 复制临时文件到本地缓存
  return this.savePhotoToLocal(photo.path, photo.id)
    .then(function(savedPath) {
      // 更新路径
      photo.path = savedPath;
      photo.status = 'local';
      
      // 保存元数据
      return storageService.saveItem('photos', photo.id, photo);
    })
    .then(function() {
      // 生成缩略图
      return this.generateThumbnail(photo.path, photo.id)
        .then(function(thumbnailPath) {
          if (thumbnailPath) {
            photo.thumbnailPath = thumbnailPath;
            // 更新照片信息
            return storageService.saveItem('photos', photo.id, photo);
          }
          return photo;
        })
        .catch(function(err) {
          console.error('生成缩略图失败:', err);
          return photo;
        });
    }.bind(this))
    .then(function() {
      return photo;
    });
}
```

### 3.2 大图预览内存优化

在photo-capture/index.js中添加内存优化:

```javascript
/**
 * 打开预览模式
 */
openPreview: function () {
  if (this.data.photoList.length === 0) {
    wx.showToast({
      title: '没有可预览的照片',
      icon: 'none'
    });
    return;
  }
  
  var initialPhotos = this.preparePreviewPhotos(0);
  
  this.setData({
    isPreviewMode: true,
    currentIndex: 0,
    showPreviewControls: true,
    previewPhotos: initialPhotos
  });
},

/**
 * 准备预览照片数据
 * 仅加载可视区域附近的照片，节省内存
 * @param {Number} centerIndex 中心照片索引
 * @private
 */
preparePreviewPhotos: function(centerIndex) {
  var photoList = this.data.photoList;
  var total = photoList.length;
  var previewArray = new Array(total);
  
  // 视窗范围：当前照片的前后2张
  var windowSize = 2;
  var startIdx = Math.max(0, centerIndex - windowSize);
  var endIdx = Math.min(total - 1, centerIndex + windowSize);
  
  // 只填充视窗范围内的照片
  for (var i = startIdx; i <= endIdx; i++) {
    previewArray[i] = photoList[i];
  }
  
  return previewArray;
},

/**
 * 滑动切换照片时的事件处理
 */
onSwiperChange: function (e) {
  var newIndex = e.detail.current;
  
  // 更新视窗照片
  var previewPhotos = this.preparePreviewPhotos(newIndex);
  
  this.setData({
    currentIndex: newIndex,
    showPreviewControls: true,
    previewPhotos: previewPhotos
  });
}
```

在WXML中使用优化的数据:

```html
<swiper class="preview-swiper" current="{{currentIndex}}" bindchange="onSwiperChange">
  <swiper-item wx:for="{{previewPhotos}}" wx:key="index">
    <!-- 只有存在照片数据时才渲染 -->
    <block wx:if="{{item}}">
      <image 
        src="{{item.path}}" 
        mode="aspectFit" 
        class="preview-image"
        bindtap="toggleControls"
        lazy-load="true"
      />
    </block>
    <!-- 未加载照片时显示占位符 -->
    <view wx:else class="preview-placeholder">
      <view class="loading-spinner"></view>
    </view>
  </swiper-item>
</swiper>
```

## 4. 技术债务记录与跟踪

创建技术债务跟踪文件，记录已识别的问题和修复计划：

```markdown
# B1-基础照片采集功能 - 技术债务记录

## 当前未解决问题

1. **内存管理优化**
   - 优先级: 高
   - 问题: 长时间拍摄照片可能导致内存泄漏
   - 解决计划: 实现照片的分批处理和内存监控

2. **ES5兼容性改进**
   - 优先级: 高
   - 问题: 代码中存在ES6+特性不符合小程序标准
   - 解决计划: 全面替换箭头函数和模板字符串

3. **照片服务URL配置**
   - 优先级: 高
   - 问题: 上传URL为硬编码占位符
   - 解决计划: 实现环境配置文件管理URL

## 下一迭代规划

1. **权限管理增强**
   - 优先级: 中
   - 问题: 相机权限处理流程不完善
   - 解决计划: 区分首次/永久拒绝，增强用户引导

2. **网络异常处理**
   - 优先级: 中
   - 问题: 照片上传缺少完善的重试和恢复机制
   - 解决计划: 实现断点续传和智能重试

## 长期改进目标

1. **UI交互优化**
   - 优先级: 低
   - 问题: 照片预览操作流程可优化
   - 解决计划: 重新设计交互流程，提升用户体验

2. **设备兼容性增强**
   - 优先级: 低
   - 问题: 在低端设备上性能不佳
   - 解决计划: 实现设备检测和自适应配置
```

## 5. 实施计划与验证策略

按照以下步骤实施修复计划，确保系统的稳定性和兼容性：

1. **修复ES5兼容性问题**
   - 全面扫描ES6+特性并替换
   - 使用微信开发者工具的ES6转ES5功能验证
   - 确保所有代码通过压缩测试

2. **解决内存泄漏问题**
   - 完善组件生命周期资源管理
   - 实现分批处理大量照片的逻辑
   - 添加临时资源的清理机制

3. **优化网络错误处理**
   - 实现重试机制和断点续传
   - 增强错误分类和用户反馈
   - 测试各种网络场景下的表现

4. **验证测试**
   - 创建自动化测试脚本验证修复
   - 在多种设备上进行实际测试
   - 执行压力测试和极端场景测试

按照优先级顺序逐步实施这些修复，每完成一项验证后再进行下一项，确保不引入新的问题。 