# 照片上传功能修复计划

## 问题概述

根据测试报告，照片上传功能目前存在以下三个主要问题：

1. **上传中断恢复问题 (IS001)**: 应用重启后无法恢复中断的上传任务
2. **内存占用过高 (IS002)**: 连续拍摄多张照片后内存占用达到初始占用的280%
3. **弱网环境优化不足 (IS003)**: 在网络条件不佳时未能调整上传策略，导致上传队列阻塞

## 修复方案

### 1. 上传任务持久化与恢复机制

**优先级**: 中
**预计工时**: 2人天
**目标**: 实现应用重启后能自动恢复中断的上传任务

**具体实施方案**:

1. **任务持久化存储**:
   - 使用微信小程序的 `wx.setStorage` API 存储上传任务队列
   - 为每个上传任务分配唯一ID，记录状态、进度、文件信息等
   - 任务数据结构设计:
     ```javascript
     {
       taskId: 'uuid-xxx',
       fileInfo: { tempFilePath, size, createTime },
       uploadStatus: 'pending|uploading|paused|completed|failed',
       progress: 0-100,
       lastUpdated: timestamp,
       retryCount: 0
     }
     ```

2. **启动时任务检查与恢复**:
   - 在应用 `onLaunch` 生命周期中检查未完成的上传任务
   - 对于状态为 `uploading` 或 `paused` 的任务，询问用户是否恢复
   - 实现优先级队列，确保高优先级任务优先上传

3. **上传任务管理器实现**:
   ```javascript
   // task-manager.js
   const TaskManager = {
     init() {
       // 初始化任务管理器，从存储中加载任务
     },
     addTask(fileInfo) {
       // 添加新任务到队列
     },
     resumeTask(taskId) {
       // 恢复指定任务
     },
     pauseTask(taskId) {
       // 暂停指定任务
     },
     updateTaskProgress(taskId, progress) {
       // 更新任务进度并持久化
     },
     persistTaskQueue() {
       // 将当前任务队列持久化到存储
     }
   };
   ```

### 2. 内存管理优化

**优先级**: 高
**预计工时**: 3人天
**目标**: 将连续拍摄20张照片的内存增长控制在初始内存的150%以内

**具体实施方案**:

1. **图片处理优化**:
   - 实现两步式图片处理流程：立即生成缩略图，延迟处理原图
   - 采用 `wx.compressImage` API 降低原图质量和大小
   - 代码实现:
     ```javascript
     function optimizeImage(tempFilePath) {
       // 立即生成缩略图用于显示
       const thumbnailPath = await generateThumbnail(tempFilePath);
       
       // 延迟压缩原图
       wx.compressImage({
         src: tempFilePath,
         quality: 80,
         success(res) {
           // 使用压缩后的图片进行上传
           uploadImage(res.tempFilePath);
         }
       });
       
       return thumbnailPath;
     }
     ```

2. **内存释放策略**:
   - 实现自动垃圾回收机制，定期清理临时文件和缓存
   - 在页面卸载时主动释放相关资源
   - 引入内存使用监控机制，超过阈值时自动触发清理
   - 实现代码:
     ```javascript
     // 在页面卸载时释放资源
     onUnload() {
       this.clearTempFiles();
       this.cancelPendingOperations();
     },
     
     // 清理临时文件
     clearTempFiles() {
       const tempFiles = this.data.tempFiles || [];
       tempFiles.forEach(file => {
         if (file.path && file.path.startsWith('wxfile://')) {
           // 尝试删除临时文件
           try {
             wx.removeSavedFile({
               filePath: file.path
             });
           } catch (e) {
             console.error('Failed to remove temp file', e);
           }
         }
       });
     },
     ```

3. **图片缓存管理**:
   - 实现LRU(最近最少使用)缓存策略，限制内存中缓存的图片数量
   - 缓存管理器代码:
     ```javascript
     // image-cache-manager.js
     const ImageCacheManager = {
       maxSize: 10, // 最多缓存10张图片
       cache: new Map(),
       
       addImage(key, image) {
         if (this.cache.size >= this.maxSize) {
           // 移除最早添加的图片
           const oldestKey = this.cache.keys().next().value;
           this.cache.delete(oldestKey);
         }
         this.cache.set(key, image);
       },
       
       getImage(key) {
         return this.cache.get(key);
       },
       
       clear() {
         this.cache.clear();
       }
     };
     ```

### 3. 智能网络感知与上传策略优化

**优先级**: 中
**预计工时**: 2人天
**目标**: 在弱网环境下自动调整上传策略，确保基本照片信息始终能够上传成功

**具体实施方案**:

1. **网络状态监测**:
   - 利用 `wx.getNetworkType` 和 `wx.onNetworkStatusChange` API 监测网络状态
   - 根据网络类型(WiFi/4G/3G/2G)自动调整上传策略
   - 实现代码:
     ```javascript
     // network-monitor.js
     const NetworkMonitor = {
       currentNetworkType: 'unknown',
       
       init() {
         // 获取初始网络状态
         wx.getNetworkType({
           success: (res) => {
             this.currentNetworkType = res.networkType;
             this.applyNetworkStrategy();
           }
         });
         
         // 监听网络状态变化
         wx.onNetworkStatusChange((res) => {
           this.currentNetworkType = res.networkType;
           this.applyNetworkStrategy();
         });
       },
       
       applyNetworkStrategy() {
         // 根据当前网络状态调整上传策略
         switch(this.currentNetworkType) {
           case 'wifi':
             UploadManager.setQuality('high');
             UploadManager.setConcurrent(3);
             break;
           case '4g':
             UploadManager.setQuality('medium');
             UploadManager.setConcurrent(2);
             break;
           case '3g':
           case '2g':
             UploadManager.setQuality('low');
             UploadManager.setConcurrent(1);
             break;
           default:
             // 未知或无网络状态
             UploadManager.pauseAllUploads();
             break;
         }
       }
     };
     ```

2. **分级上传策略**:
   - 实现两阶段上传逻辑：优先上传缩略图和元数据，成功后再上传原图
   - 在弱网环境下自动降低图片质量和分辨率
   - 代码实现:
     ```javascript
     // upload-manager.js
     const UploadManager = {
       quality: 'high', // high, medium, low
       concurrent: 3,   // 并发上传数
       
       setQuality(level) {
         this.quality = level;
       },
       
       setConcurrent(num) {
         this.concurrent = num;
       },
       
       uploadPhoto(photo) {
         // 第一阶段：上传缩略图和元数据
         this.uploadThumbnail(photo)
           .then(res => {
             // 记录远程ID，用于后续关联原图
             photo.remoteId = res.id;
             
             // 第二阶段：根据网络状况上传原图
             if (NetworkMonitor.currentNetworkType === 'wifi') {
               return this.uploadOriginal(photo);
             } else {
               // 非WiFi环境，加入后台任务队列，等待更好的网络
               return BackgroundTaskManager.addTask({
                 type: 'upload_original',
                 data: photo,
                 requiresWifi: true
               });
             }
           });
       }
     };
     ```

3. **智能重试机制**:
   - 实现指数退避算法进行智能重试，避免频繁重试造成资源浪费
   - 在网络恢复后自动恢复上传
   - 实现代码:
     ```javascript
     // retry-strategy.js
     function exponentialBackoff(attempt) {
       const baseDelay = 1000; // 1秒
       const maxDelay = 30000; // 最长30秒
       const delay = Math.min(baseDelay * Math.pow(2, attempt), maxDelay);
       // 增加随机抖动，避免同时重试
       return delay + Math.random() * 1000;
     }
     
     function retryUpload(task, maxAttempts = 5) {
       if (task.retryCount >= maxAttempts) {
         console.error('Max retry attempts reached');
         return Promise.reject('Max retries reached');
       }
       
       task.retryCount++;
       const delay = exponentialBackoff(task.retryCount);
       
       return new Promise((resolve) => {
         setTimeout(() => {
           console.log(`Retrying upload, attempt ${task.retryCount}`);
           resolve(uploadTask(task));
         }, delay);
       });
     }
     ```

## 测试验证计划

针对上述修复方案，我们需要进行以下测试验证:

1. **上传恢复测试**:
   - 测试场景: 上传过程中强制关闭应用，然后重新打开
   - 预期结果: 应用能够检测到未完成的上传任务，并提示用户是否继续
   - 测试方法: 使用微信开发者工具和真机测试

2. **内存占用测试**:
   - 测试场景: 连续拍摄和上传20张照片
   - 预期结果: 内存占用不超过应用初始占用的150%
   - 测试方法: 使用微信开发者工具的性能监控面板

3. **弱网环境测试**:
   - 测试场景: 在模拟的2G/3G网络环境下上传照片
   - 预期结果: 缩略图和元数据能够快速上传，原图上传自动调整为低质量或等待更好的网络
   - 测试方法: 使用网络限速工具模拟弱网环境

## 实施时间表

| 阶段 | 任务 | 时间预估 | 负责人 |
|------|------|----------|--------|
| 1 | 上传任务持久化与恢复机制开发 | 2025-04-08 ~ 2025-04-09 | 待定 |
| 2 | 内存管理优化 | 2025-04-08 ~ 2025-04-10 | 待定 |
| 3 | 智能网络感知与上传策略优化 | 2025-04-11 ~ 2025-04-12 | 待定 |
| 4 | 集成测试与问题修复 | 2025-04-13 ~ 2025-04-14 | 待定 |
| 5 | 性能测试与优化 | 2025-04-15 | 待定 |
| 6 | 文档更新与发布准备 | 2025-04-16 | 待定 |

预计总工期: 9个工作日
目标发布日期: 2025-04-17 