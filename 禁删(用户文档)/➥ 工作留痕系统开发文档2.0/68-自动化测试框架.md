# 工作留痕系统 - 自动化测试框架

## 1. 测试框架概述

微信小程序的自动化测试具有特殊性，需要同时考虑平台限制和业务需求。本框架针对工作留痕系统提供完整的测试方案，确保各功能单元可靠运行。

### 1.1 测试目标

1. **验证功能正确性**：确保每个功能单元按预期工作
2. **检测性能问题**：识别潜在的性能瓶颈
3. **保障兼容性**：验证不同设备和基础库版本下的一致行为
4. **预防循环依赖**：自动检测并预防代码中的循环依赖
5. **验证离线功能**：确保离线状态下的数据完整性

### 1.2 测试类型

本框架包含以下测试类型：

1. **单元测试**：针对独立功能模块的测试
2. **组件测试**：针对UI组件的渲染和交互测试
3. **集成测试**：针对多模块协作的测试
4. **端到端测试**：模拟用户行为的完整流程测试
5. **性能测试**：针对关键操作的性能指标测试

## 2. 基础测试基础设施

### 2.1 测试助手工具

创建基础的测试助手函数，用于简化测试流程：

```javascript
// utils/testHelper.js
var TestHelper = {
  // 测试运行器
  runTest: function(testName, testFn) {
    console.log('开始测试:', testName);
    var startTime = Date.now();
    
    try {
      testFn();
      console.log('✅ 测试通过:', testName, '(耗时:', Date.now() - startTime, 'ms)');
      return true;
    } catch (error) {
      console.error('❌ 测试失败:', testName, error);
      return false;
    }
  },
  
  // 运行测试套件
  runTestSuite: function(suiteName, tests) {
    console.log('======= 测试套件:', suiteName, '=======');
    var passed = 0;
    var failed = 0;
    
    for (var testName in tests) {
      var result = this.runTest(testName, tests[testName]);
      if (result) {
        passed++;
      } else {
        failed++;
      }
    }
    
    console.log('测试套件结果:', suiteName, '通过:', passed, '失败:', failed);
    return { passed: passed, failed: failed };
  },
  
  // 模拟网络状态
  mockNetworkStatus: function(status) {
    // 保存原始网络状态API
    if (!this._originalGetNetworkType) {
      this._originalGetNetworkType = wx.getNetworkType;
    }
    
    // 替换为模拟实现
    wx.getNetworkType = function(options) {
      setTimeout(function() {
        options.success && options.success({ networkType: status });
        options.complete && options.complete();
      }, 0);
    };
  },
  
  // 恢复网络状态API
  restoreNetworkStatus: function() {
    if (this._originalGetNetworkType) {
      wx.getNetworkType = this._originalGetNetworkType;
      this._originalGetNetworkType = null;
    }
  }
};

module.exports = TestHelper;
```

### 2.2 基础断言库

创建简单的断言库，用于验证测试结果：

```javascript
// utils/assert.js
var Assert = {
  // 判断是否相等
  equal: function(actual, expected, message) {
    if (actual !== expected) {
      throw new Error(message || '断言失败: ' + actual + ' !== ' + expected);
    }
  },
  
  // 判断是否深度相等（对象比较）
  deepEqual: function(actual, expected, message) {
    var actualJson = JSON.stringify(actual);
    var expectedJson = JSON.stringify(expected);
    
    if (actualJson !== expectedJson) {
      throw new Error(message || '断言失败: 对象不相等');
    }
  },
  
  // 判断是否为真
  isTrue: function(value, message) {
    if (value !== true) {
      throw new Error(message || '断言失败: 值不为true');
    }
  },
  
  // 判断是否为假
  isFalse: function(value, message) {
    if (value !== false) {
      throw new Error(message || '断言失败: 值不为false');
    }
  },
  
  // 判断函数是否抛出错误
  throws: function(fn, message) {
    try {
      fn();
      throw new Error(message || '断言失败: 未抛出预期错误');
    } catch (error) {
      // 预期的错误，测试通过
      return error;
    }
  }
};

module.exports = Assert;
```

### 2.3 小程序API模拟工具

为了测试依赖微信API的功能，创建API模拟工具：

```javascript
// utils/wxMock.js
var WxMock = {
  // 存储原始API
  _originalApis: {},
  
  // 模拟wx.request
  mockRequest: function(mockResponse) {
    this._saveOriginal('request');
    
    wx.request = function(options) {
      setTimeout(function() {
        if (mockResponse.success) {
          options.success && options.success(mockResponse.data);
        } else {
          options.fail && options.fail(mockResponse.error || { errMsg: '请求失败' });
        }
        options.complete && options.complete();
      }, mockResponse.delay || 0);
    };
  },
  
  // 模拟wx.chooseMedia/chooseImage
  mockMediaChooser: function(mockResult) {
    // 保存原始API
    if (wx.chooseMedia) {
      this._saveOriginal('chooseMedia');
      
      wx.chooseMedia = function(options) {
        setTimeout(function() {
          if (mockResult.success) {
            options.success && options.success(mockResult.data);
          } else {
            options.fail && options.fail(mockResult.error || { errMsg: '选择媒体失败' });
          }
          options.complete && options.complete();
        }, mockResult.delay || 0);
      };
    }
    
    // 兼容旧版API
    this._saveOriginal('chooseImage');
    
    wx.chooseImage = function(options) {
      setTimeout(function() {
        if (mockResult.success) {
          // 转换为旧API格式
          var result = {
            tempFilePaths: mockResult.data.tempFiles.map(function(f) { return f.tempFilePath; }),
            tempFiles: mockResult.data.tempFiles
          };
          options.success && options.success(result);
        } else {
          options.fail && options.fail(mockResult.error || { errMsg: '选择图片失败' });
        }
        options.complete && options.complete();
      }, mockResult.delay || 0);
    };
  },
  
  // 模拟wx.setStorage/getStorage
  mockStorage: function() {
    var memoryStorage = {};
    
    this._saveOriginal('setStorage');
    this._saveOriginal('getStorage');
    this._saveOriginal('removeStorage');
    
    wx.setStorage = function(options) {
      memoryStorage[options.key] = options.data;
      options.success && options.success();
      options.complete && options.complete();
    };
    
    wx.getStorage = function(options) {
      if (memoryStorage.hasOwnProperty(options.key)) {
        options.success && options.success({ data: memoryStorage[options.key] });
      } else {
        options.fail && options.fail({ errMsg: 'getStorage:fail data not found' });
      }
      options.complete && options.complete();
    };
    
    wx.removeStorage = function(options) {
      delete memoryStorage[options.key];
      options.success && options.success();
      options.complete && options.complete();
    };
  },
  
  // 保存原始API
  _saveOriginal: function(apiName) {
    if (!this._originalApis[apiName]) {
      this._originalApis[apiName] = wx[apiName];
    }
  },
  
  // 恢复单个API
  restoreApi: function(apiName) {
    if (this._originalApis[apiName]) {
      wx[apiName] = this._originalApis[apiName];
      delete this._originalApis[apiName];
    }
  },
  
  // 恢复所有被模拟的API
  restoreAll: function() {
    for (var apiName in this._originalApis) {
      wx[apiName] = this._originalApis[apiName];
    }
    this._originalApis = {};
  }
};

module.exports = WxMock;
```

## 3. 功能模块测试实例

### 3.1 存储服务测试

测试本地存储管理服务，确保数据的正确存储、检索和清理：

```javascript
// tests/storageServiceTest.js
var TestHelper = require('../utils/testHelper.js');
var Assert = require('../utils/assert.js');
var WxMock = require('../utils/wxMock.js');
var StorageService = require('../services/storageService.js');

function runStorageServiceTests() {
  // 初始化模拟工具
  WxMock.mockStorage();
  
  var tests = {
    '基本存储和获取': function() {
      var testData = { id: 'test123', name: '测试数据', value: 42 };
      
      // 保存数据
      StorageService.saveData('testKey', testData);
      
      // 获取数据
      var retrievedData = StorageService.getData('testKey');
      
      // 验证
      Assert.deepEqual(retrievedData, testData, '获取的数据应与保存的数据一致');
    },
    
    '处理大数据量': function() {
      // 生成大量数据
      var largeData = [];
      for (var i = 0; i < 1000; i++) {
        largeData.push({
          id: 'item_' + i,
          value: 'value_' + i,
          timestamp: Date.now() + i
        });
      }
      
      // 保存大数据
      var result = StorageService.saveData('largeData', largeData);
      
      // 验证结果
      Assert.isTrue(result.success, '大数据存储应该成功');
      
      // 验证清理策略
      if (result.cleaned) {
        Assert.isTrue(result.cleaned > 0, '应该清理了一些旧数据');
      }
      
      // 获取数据
      var retrieved = StorageService.getData('largeData');
      
      // 验证数据是否完整
      Assert.equal(retrieved.length, largeData.length, '数据长度应保持一致');
    },
    
    '数据清理策略': function() {
      // 生成多组数据
      for (var i = 0; i < 10; i++) {
        StorageService.saveData('test_key_' + i, {
          value: 'data_' + i,
          timestamp: Date.now() - (10 - i) * 86400000 // 递增的时间戳
        });
      }
      
      // 触发清理
      var cleanResult = StorageService.cleanOldData(5); // 保留5条最新记录
      
      // 验证
      Assert.equal(cleanResult.cleaned, 5, '应该清理了5条记录');
      Assert.equal(cleanResult.remaining, 5, '应该剩余5条记录');
      
      // 检查剩余的是否是最新的
      for (var i = 5; i < 10; i++) {
        var data = StorageService.getData('test_key_' + i);
        Assert.equal(data.value, 'data_' + i, '最新数据应该保留');
      }
      
      // 检查旧的是否已清理
      for (var i = 0; i < 5; i++) {
        var data = StorageService.getData('test_key_' + i);
        Assert.equal(data, null, '旧数据应该已清理');
      }
    },
    
    '错误处理': function() {
      // 测试空键
      var error = Assert.throws(function() {
        StorageService.saveData('', { value: 'test' });
      }, '空键应该抛出错误');
      
      // 测试无效数据
      error = Assert.throws(function() {
        StorageService.saveData('testKey', undefined);
      }, '无效数据应该抛出错误');
      
      // 测试获取不存在的键
      var nonExistentData = StorageService.getData('nonExistentKey');
      Assert.equal(nonExistentData, null, '获取不存在的键应返回null');
    }
  };
  
  // 运行测试套件
  var result = TestHelper.runTestSuite('存储服务测试', tests);
  
  // 恢复模拟
  WxMock.restoreAll();
  
  return result;
}

module.exports = {
  run: runStorageServiceTests
};
```

### 3.2 照片采集服务测试

测试照片采集和处理功能，确保正确处理图片选择、压缩和存储：

```javascript
// tests/photoServiceTest.js
var TestHelper = require('../utils/testHelper.js');
var Assert = require('../utils/assert.js');
var WxMock = require('../utils/wxMock.js');
var PhotoService = require('../services/photoService.js');

function runPhotoServiceTests() {
  // 初始化模拟
  WxMock.mockStorage();
  
  // 模拟照片选择结果
  var mockPhotoResult = {
    success: true,
    data: {
      type: 'image',
      tempFiles: [
        { tempFilePath: 'wxfile://temp/photo1.jpg', size: 120000 },
        { tempFilePath: 'wxfile://temp/photo2.jpg', size: 150000 }
      ]
    }
  };
  
  WxMock.mockMediaChooser(mockPhotoResult);
  
  // 模拟压缩图片API
  WxMock._saveOriginal('compressImage');
  wx.compressImage = function(options) {
    // 模拟压缩后图片路径
    var compressedPath = options.src.replace('.jpg', '_compressed.jpg');
    setTimeout(function() {
      options.success && options.success({ tempFilePath: compressedPath });
      options.complete && options.complete();
    }, 100);
  };
  
  var tests = {
    '照片选择与获取': function() {
      var that = this;
      
      // 添加异步测试支持
      var done = false;
      var timeout = setTimeout(function() {
        if (!done) {
          throw new Error('测试超时');
        }
      }, 1000);
      
      // 调用照片选择
      PhotoService.choosePhotos({
        success: function(photos) {
          clearTimeout(timeout);
          
          // 验证返回的照片数组
          Assert.equal(photos.length, 2, '应该返回2张照片');
          Assert.equal(photos[0].path.indexOf('_compressed.jpg') > -1, true, '照片应该已被压缩');
          
          // 获取已保存照片
          var savedPhotos = PhotoService.getSavedPhotos();
          Assert.equal(savedPhotos.length, 2, '应该保存了2张照片');
          
          done = true;
        },
        fail: function(error) {
          clearTimeout(timeout);
          throw new Error('选择照片失败: ' + error.errMsg);
        }
      });
    },
    
    '照片处理与过滤': function() {
      // 模拟一组照片数据
      var testPhotos = [
        { id: 'p1', path: 'wxfile://temp/p1.jpg', size: 50000, timestamp: Date.now() },
        { id: 'p2', path: 'wxfile://temp/p2.jpg', size: 120000, timestamp: Date.now() - 5000 },
        { id: 'p3', path: 'wxfile://temp/p3.jpg', size: 200000, timestamp: Date.now() - 10000 }
      ];
      
      // 保存测试照片
      PhotoService.savePhotos(testPhotos);
      
      // 按大小过滤照片
      var largePhotos = PhotoService.filterPhotosBySize(100000);
      Assert.equal(largePhotos.length, 2, '大于100KB的照片应有2张');
      Assert.equal(largePhotos[0].id, 'p2', '第一张大照片应为p2');
      
      // 按时间排序照片
      var sortedPhotos = PhotoService.sortPhotosByTime();
      Assert.equal(sortedPhotos[0].id, 'p1', '最新的照片应为p1');
      Assert.equal(sortedPhotos[2].id, 'p3', '最旧的照片应为p3');
    },
    
    '离线队列管理': function() {
      // 模拟离线状态
      TestHelper.mockNetworkStatus('none');
      
      // 尝试上传照片
      var photo = { id: 'offline1', path: 'wxfile://temp/offline1.jpg', size: 80000 };
      var uploadResult = PhotoService.uploadPhoto(photo);
      
      // 验证照片已加入队列
      Assert.equal(uploadResult.success, false, '离线时上传应失败');
      Assert.equal(uploadResult.queued, true, '照片应被加入队列');
      
      // 获取等待上传的队列
      var queue = PhotoService.getPendingUploadQueue();
      Assert.equal(queue.length >= 1, true, '队列应至少有一张照片');
      Assert.equal(queue.filter(function(p) { return p.id === 'offline1'; }).length, 1, '队列中应有测试照片');
      
      // 恢复网络
      TestHelper.mockNetworkStatus('wifi');
      
      // 处理上传队列
      PhotoService.processPendingQueue({
        onProgress: function(progress) {
          // 接收进度通知
        },
        onComplete: function(result) {
          // 验证队列处理结果
          Assert.equal(result.processed.length >= 1, true, '至少处理了一张照片');
          
          // 验证队列已清空
          var remainingQueue = PhotoService.getPendingUploadQueue();
          Assert.equal(remainingQueue.length, 0, '队列应已清空');
        }
      });
    }
  };
  
  // 运行测试
  var result = TestHelper.runTestSuite('照片服务测试', tests);
  
  // 恢复模拟
  WxMock.restoreAll();
  TestHelper.restoreNetworkStatus();
  
  return result;
}

module.exports = {
  run: runPhotoServiceTests
};
```

### 3.3 UI组件测试

测试工作留痕系统的UI组件，确保正确渲染和响应用户交互：

```
// tests/componentTest.js

// 测试重点：
// 1. 组件渲染 - 确保组件正确渲染所有元素
// 2. 样式应用 - 验证样式正确应用到元素
// 3. 交互响应 - 确保组件正确响应用户操作
// 4. 状态变化 - 验证状态变化导致UI正确更新
// 5. 适配性 - 测试在不同屏幕尺寸下的显示

// 测试方法：
// 1. 模拟组件创建和渲染
// 2. 验证DOM结构和属性
// 3. 模拟用户交互（点击、滑动、输入）
// 4. 检查事件处理和回调触发
// 5. 验证组件状态变化
```

关键UI组件测试包括：

1. **照片网格组件测试** - 验证照片显示、布局调整和选择功能
2. **表单组件测试** - 验证输入验证、提交处理和错误展示
3. **留痕类型选择器测试** - 验证分类显示、选择响应和默认值处理

测试应关注组件在不同设备和方向上的适配性，确保界面在各种尺寸屏幕上正确显示。

### 3.4 集成测试

集成测试验证多个功能单元协同工作的能力，确保系统作为一个整体正常运行：

```
// tests/integrationTest.js

// 集成测试重点：
// 1. 模块协作 - 验证模块间通信和数据传递
// 2. 功能流程 - 测试完整业务流程的执行
// 3. 状态管理 - 验证全局状态变化对各模块的影响
// 4. 异常处理 - 测试模块互动中的错误传递与恢复
// 5. 性能影响 - 评估模块交互对性能的影响
```

工作留痕系统的关键集成测试场景包括：

1. **完整留痕流程测试** - 从选择类型、拍照到提交的完整流程
2. **离线同步测试** - 验证离线创建的留痕记录能在网络恢复后同步
3. **数据一致性测试** - 确保多个模块共享的数据保持一致

集成测试应特别关注不同网络环境下的系统行为，确保在网络波动情况下数据不丢失且功能完整。模拟实际用户场景，如：

- 拍照过程中网络中断
- 提交表单时网络延迟
- 多页面间导航带来的状态保持

## 4. 性能测试

性能测试旨在识别和解决可能影响用户体验的性能瓶颈：

```javascript
// tests/performanceTest.js
var TestHelper = require('../utils/testHelper.js');

function runPerformanceTests() {
  // 关键性能指标
  var metrics = {
    // 启动时间
    startupTime: function() {
      var startTime = Date.now();
      
      // 模拟应用启动过程
      // ...应用初始化代码...
      
      return Date.now() - startTime;
    },
    
    // 页面渲染时间
    pageRenderTime: function(pagePath, params) {
      var startTime = Date.now();
      
      // 测量页面渲染时间
      // ...页面创建和渲染代码...
      
      return Date.now() - startTime;
    },
    
    // 照片处理时间
    photoProcessingTime: function(photoCount, photoSize) {
      var startTime = Date.now();
      
      // 生成测试照片数据
      var photos = [];
      for (var i = 0; i < photoCount; i++) {
        photos.push({
          path: 'test_photo_' + i + '.jpg',
          size: photoSize
        });
      }
      
      // 执行照片处理
      // ...照片处理代码...
      
      return Date.now() - startTime;
    },
    
    // 表单提交响应时间
    formSubmissionTime: function() {
      var startTime = Date.now();
      
      // 模拟表单提交过程
      // ...表单处理和提交代码...
      
      return Date.now() - startTime;
    },
    
    // 存储操作时间
    storageOperationTime: function(dataSize, operationType) {
      var startTime = Date.now();
      
      // 根据操作类型执行不同测试
      switch (operationType) {
        case 'read':
          // 读取测试
          // ...存储读取代码...
          break;
        case 'write':
          // 写入测试
          // ...存储写入代码...
          break;
        case 'delete':
          // 删除测试
          // ...存储删除代码...
          break;
      }
      
      return Date.now() - startTime;
    }
  };
  
  // 设置性能基准
  var benchmarks = {
    startupTime: 500, // 毫秒
    pageRenderTime: 300, // 毫秒
    photoProcessingTime: 200, // 毫秒/张
    formSubmissionTime: 1000, // 毫秒
    storageOperationRead: 50, // 毫秒
    storageOperationWrite: 100, // 毫秒
    storageOperationDelete: 50 // 毫秒
  };
  
  // 运行性能测试
  var results = {
    startup: metrics.startupTime(),
    mainPageRender: metrics.pageRenderTime('pages/index/index'),
    photoProcess: metrics.photoProcessingTime(5, 100000) / 5, // 平均每张处理时间
    formSubmit: metrics.formSubmissionTime(),
    storageRead: metrics.storageOperationTime(10000, 'read'),
    storageWrite: metrics.storageOperationTime(10000, 'write'),
    storageDelete: metrics.storageOperationTime(10000, 'delete')
  };
  
  // 分析结果
  var analysis = {};
  for (var key in results) {
    var benchmark = benchmarks[key] || 1000; // 默认基准
    var ratio = results[key] / benchmark;
    
    analysis[key] = {
      value: results[key],
      benchmark: benchmark,
      ratio: ratio,
      status: ratio <= 1 ? '通过' : (ratio <= 1.5 ? '警告' : '失败')
    };
  }
  
  // 输出分析结果
  console.log('===== 性能测试结果 =====');
  for (var key in analysis) {
    var item = analysis[key];
    console.log(
      key + ': ' + item.value + 'ms',
      '(基准: ' + item.benchmark + 'ms)',
      '状态: ' + item.status
    );
  }
  
  return analysis;
}

module.exports = {
  run: runPerformanceTests
}
```

### 4.1 性能测试要点

1. **关键指标监控**：
   - 页面加载时间 - 首屏渲染时间不超过300ms
   - 表单响应时间 - 用户输入反馈不超过100ms
   - 图片处理速度 - 单张照片压缩不超过500ms
   - 存储操作延迟 - 数据读写不超过200ms

2. **性能基准设定**：
   - 使用实测值建立最初基准
   - 随版本迭代逐步提高基准要求
   - 不同设备性能差异考量

3. **大数据量测试**：
   - 模拟大量照片上传场景
   - 测试长期使用后的数据累积影响
   - 验证分页和懒加载性能

## 5. 循环依赖检测

循环依赖会导致小程序性能下降、启动缓慢，甚至在某些情况下导致意外行为：

```javascript
// tools/dependencyChecker.js
var fs = require('fs');
var path = require('path');

// 依赖关系图
var dependencyGraph = {};
// 已检查文件集合
var checkedFiles = new Set();

// 分析文件依赖
function analyzeDependencies(file, baseDir) {
  // 避免重复分析
  if (checkedFiles.has(file)) {
    return;
  }
  
  checkedFiles.add(file);
  var dependencies = [];
  dependencyGraph[file] = dependencies;
  
  try {
    var content = fs.readFileSync(path.join(baseDir, file), 'utf8');
    
    // 分析require语句
    var requireRegex = /require\(['"]([^'"]+)['"]\)/g;
    var match;
    
    while ((match = requireRegex.exec(content)) !== null) {
      var dependency = match[1];
      
      // 处理相对路径
      if (dependency.startsWith('./') || dependency.startsWith('../')) {
        dependency = path.normalize(path.join(path.dirname(file), dependency));
        
        // 添加.js扩展名（如果缺失）
        if (!dependency.endsWith('.js')) {
          dependency += '.js';
        }
      } else if (!dependency.startsWith('/')) {
        // 处理非绝对路径的模块引用
        dependency = path.join('miniprogram_npm', dependency, 'index.js');
      }
      
      dependencies.push(dependency);
      
      // 递归分析依赖
      analyzeDependencies(dependency, baseDir);
    }
    
    // 分析import语句
    var importRegex = /import\s+(?:.+\s+from\s+)?['"]([^'"]+)['"]/g;
    while ((match = importRegex.exec(content)) !== null) {
      var dependency = match[1];
      
      // 处理相对路径
      if (dependency.startsWith('./') || dependency.startsWith('../')) {
        dependency = path.normalize(path.join(path.dirname(file), dependency));
        
        // 添加.js扩展名（如果缺失）
        if (!dependency.endsWith('.js')) {
          dependency += '.js';
        }
      } else if (!dependency.startsWith('/')) {
        // 处理非绝对路径的模块引用
        dependency = path.join('miniprogram_npm', dependency, 'index.js');
      }
      
      dependencies.push(dependency);
      
      // 递归分析依赖
      analyzeDependencies(dependency, baseDir);
    }
  } catch (err) {
    console.error('分析文件依赖失败:', file, err);
  }
}

// 检测循环依赖
function detectCycles() {
  var cycles = [];
  
  // 对每个文件检查循环依赖
  Object.keys(dependencyGraph).forEach(function(file) {
    var visited = new Set();
    var pathStack = [];
    
    function dfs(currentFile) {
      // 如果当前文件已在路径栈中，表示检测到循环依赖
      var cycleStart = pathStack.indexOf(currentFile);
      if (cycleStart !== -1) {
        cycles.push(pathStack.slice(cycleStart).concat(currentFile));
        return;
      }
      
      // 如果已经访问过该文件，或文件不在依赖图中，则跳过
      if (visited.has(currentFile) || !dependencyGraph[currentFile]) {
        return;
      }
      
      visited.add(currentFile);
      pathStack.push(currentFile);
      
      // 递归检查所有依赖
      dependencyGraph[currentFile].forEach(dfs);
      
      pathStack.pop();
    }
    
    dfs(file);
  });
  
  return cycles;
}

// 主函数
function checkDependencies(baseDir) {
  console.log('分析项目依赖关系...');
  
  // 获取所有JS文件
  function getAllJsFiles(dir, fileList = []) {
    var files = fs.readdirSync(path.join(baseDir, dir));
    
    files.forEach(function(file) {
      var filePath = path.join(dir, file);
      var stat = fs.statSync(path.join(baseDir, filePath));
      
      if (stat.isDirectory() && !filePath.startsWith('miniprogram_npm')) {
        getAllJsFiles(filePath, fileList);
      } else if (file.endsWith('.js')) {
        fileList.push(filePath);
      }
    });
    
    return fileList;
  }
  
  var jsFiles = getAllJsFiles('');
  
  // 分析所有文件依赖
  jsFiles.forEach(function(file) {
    analyzeDependencies(file, baseDir);
  });
  
  // 检测循环依赖
  var cycles = detectCycles();
  
  // 输出结果
  if (cycles.length > 0) {
    console.log('检测到', cycles.length, '个循环依赖:');
    cycles.forEach(function(cycle, index) {
      console.log('循环依赖 #' + (index + 1) + ':');
      console.log('  ' + cycle.join(' -> '));
    });
    return false;
  } else {
    console.log('未检测到循环依赖，代码结构良好');
    return true;
  }
}

module.exports = {
  check: checkDependencies
};
```

### 5.1 循环依赖解决方案

当检测到循环依赖时，可采用以下方法解决：

1. **重构模块设计**：
   - 拆分大模块为小模块
   - 使用更细粒度的功能拆分

2. **引入中间层**：
   - 创建中间层模块
   - 使依赖成为单向流动

3. **使用依赖注入**：
   - 通过参数传递依赖对象
   - 避免直接require形成闭环

4. **事件总线模式**：
   - 模块通过事件通信
   - 解除直接依赖关系

## 6. 测试执行与报告

提供统一的测试执行和报告生成机制：

```javascript
// tools/testRunner.js
var fs = require('fs');
var path = require('path');

// 测试管理器
var TestRunner = {
  // 存储测试结果
  results: {
    total: 0,
    passed: 0,
    failed: 0,
    skipped: 0,
    duration: 0,
    tests: []
  },
  
  // 重置测试结果
  reset: function() {
    this.results = {
      total: 0,
      passed: 0,
      failed: 0,
      skipped: 0,
      duration: 0,
      tests: []
    };
  },
  
  // 收集测试文件
  collectTests: function(testDir) {
    var testFiles = [];
    
    function readDir(dir) {
      var files = fs.readdirSync(dir);
      
      files.forEach(function(file) {
        var fullPath = path.join(dir, file);
        var stat = fs.statSync(fullPath);
        
        if (stat.isDirectory()) {
          readDir(fullPath);
        } else if (file.endsWith('Test.js')) {
          testFiles.push(fullPath);
        }
      });
    }
    
    readDir(testDir);
    return testFiles;
  },
  
  // 执行测试
  runTests: function(testDir, options) {
    options = options || {};
    this.reset();
    
    console.log('=== 开始测试 ===');
    var startTime = Date.now();
    
    var testFiles = this.collectTests(testDir);
    console.log('发现', testFiles.length, '个测试文件');
    
    // 执行每个测试文件
    testFiles.forEach(function(testFile) {
      try {
        var test = require(testFile);
        var testName = path.basename(testFile, '.js');
        
        console.log('执行测试:', testName);
        var testStartTime = Date.now();
        
        if (typeof test.run === 'function') {
          var result = test.run();
          var testDuration = Date.now() - testStartTime;
          
          var testResult = {
            name: testName,
            duration: testDuration,
            passed: true,
            details: result
          };
          
          if (result.failed && result.failed > 0) {
            testResult.passed = false;
            this.results.failed++;
          } else {
            this.results.passed++;
          }
          
          this.results.tests.push(testResult);
          this.results.total++;
          
          console.log(
            testResult.passed ? '✅ 通过:' : '❌ 失败:',
            testName,
            '(耗时:', testDuration, 'ms)'
          );
        } else {
          console.warn('警告: 测试文件没有run方法:', testName);
          this.results.skipped++;
        }
      } catch (err) {
        console.error('执行测试失败:', testFile, err);
        this.results.failed++;
        this.results.total++;
        
        this.results.tests.push({
          name: path.basename(testFile, '.js'),
          duration: 0,
          passed: false,
          error: err.message || err
        });
      }
    }, this);
    
    this.results.duration = Date.now() - startTime;
    
    console.log('=== 测试完成 ===');
    console.log('总计:', this.results.total, '测试');
    console.log('通过:', this.results.passed);
    console.log('失败:', this.results.failed);
    console.log('跳过:', this.results.skipped);
    console.log('总耗时:', this.results.duration, 'ms');
    
    // 生成报告
    if (options.generateReport) {
      this.generateReport(options.reportPath || 'test-report.json');
    }
    
    return this.results;
  },
  
  // 生成测试报告
  generateReport: function(reportPath) {
    var report = {
      timestamp: new Date().toISOString(),
      summary: {
        total: this.results.total,
        passed: this.results.passed,
        failed: this.results.failed,
        skipped: this.results.skipped,
        duration: this.results.duration,
        passRate: this.results.total > 0 
          ? (this.results.passed / this.results.total * 100).toFixed(2) + '%' 
          : '0%'
      },
      tests: this.results.tests
    };
    
    // 生成JSON报告
    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
    console.log('测试报告已生成:', reportPath);
    
    // 生成HTML报告
    var htmlReportPath = reportPath.replace('.json', '.html');
    
    var htmlContent = `
      <!DOCTYPE html>
      <html>
      <head>
        <title>工作留痕系统测试报告</title>
        <style>
          body { font-family: Arial, sans-serif; line-height: 1.6; }
          .container { max-width: 1000px; margin: 0 auto; padding: 20px; }
          h1 { color: #333; }
          .summary { background: #f5f5f5; padding: 15px; border-radius: 5px; margin-bottom: 20px; }
          .summary-item { margin: 5px 0; }
          .test-list { border-collapse: collapse; width: 100%; }
          .test-list th, .test-list td { border: 1px solid #ddd; padding: 8px; text-align: left; }
          .test-list th { background-color: #f2f2f2; }
          .passed { color: green; }
          .failed { color: red; }
          .test-row:nth-child(even) { background-color: #f9f9f9; }
        </style>
      </head>
      <body>
        <div class="container">
          <h1>工作留痕系统测试报告</h1>
          <div class="summary">
            <h2>测试摘要</h2>
            <div class="summary-item">时间: ${report.timestamp}</div>
            <div class="summary-item">总测试数: ${report.summary.total}</div>
            <div class="summary-item">通过: ${report.summary.passed}</div>
            <div class="summary-item">失败: ${report.summary.failed}</div>
            <div class="summary-item">跳过: ${report.summary.skipped}</div>
            <div class="summary-item">总耗时: ${report.summary.duration}ms</div>
            <div class="summary-item">通过率: ${report.summary.passRate}</div>
          </div>
          
          <h2>测试详情</h2>
          <table class="test-list">
            <tr>
              <th>测试名称</th>
              <th>状态</th>
              <th>耗时 (ms)</th>
              <th>详情</th>
            </tr>
            ${report.tests.map(function(test) {
              return `
                <tr class="test-row">
                  <td>${test.name}</td>
                  <td class="${test.passed ? 'passed' : 'failed'}">${test.passed ? '通过' : '失败'}</td>
                  <td>${test.duration}</td>
                  <td>${test.error || (test.details ? JSON.stringify(test.details).substring(0, 100) + '...' : '')}</td>
                </tr>
              `;
            }).join('')}
          </table>
        </div>
      </body>
      </html>
    `;
    
    fs.writeFileSync(htmlReportPath, htmlContent);
    console.log('HTML报告已生成:', htmlReportPath);
  }
};

module.exports = TestRunner;
```

### 6.1 使用测试框架

测试框架的使用方法：

1. **配置测试环境**：
   ```javascript
   // 设置环境变量
   process.env.NODE_ENV = 'test';
   ```

2. **执行测试**：
   ```javascript
   // 运行所有测试
   var TestRunner = require('./tools/testRunner');
   TestRunner.runTests('./tests', { generateReport: true });
   ```

3. **CI集成**：
   - 配置自动执行测试脚本
   - 设置测试失败时阻止部署
   - 保存测试报告作为构建产物

## 7. 最佳实践与总结

有效使用自动化测试框架的关键要点：

1. **测试覆盖率目标**：
   - 核心功能单元测试覆盖率 > 90%
   - 关键业务流程集成测试覆盖率 > 80%
   - UI组件测试覆盖率 > 70%

2. **测试驱动开发**：
   - 先编写测试，再实现功能
   - 明确功能验收标准，减少后期调整

3. **定期回归测试**：
   - 每次提交前执行单元测试
   - 每周执行完整测试套件
   - 每次发布前执行性能测试

4. **持续优化测试**：
   - 根据实际问题更新测试用例
   - 对测试失败的场景进行深入分析
   - 构建专项测试针对性能瓶颈